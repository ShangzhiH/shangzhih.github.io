<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8"> 
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="Shangzhi HUANG" />
        <meta name="copyright" content="Shangzhi HUANG" />

        <meta property="og:type" content="article" />
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="算法, 深度学习, 《深度学习与神经网络》笔记, 深度学习, " />

<meta property="og:title" content="《深度学习与神经网络》笔记1  - 使用神经网络识别手写数字 "/>
<meta property="og:url" content="/shen-du-xue-xi-yu-shen-jing-wang-luo-bi-ji-1.html" />
<meta property="og:description" content="深度学习算是现在机器学习领域非常热门的方向了，虽然一直有了解并且简单用过，但是对于其中的详细原理和来龙去脉都是略知一二，于是一直想系统学习一下该领域的相关知识。《Neural Networks and Deep Learning》是一份非常好的入门材料，讲解详细而且不光是介绍了理论知识，更重要的是介绍了每一步的来龙去脉以及为什么要这样做。在线文档是英文版的，我这份总结笔记的很大部分是结合原文根据自己的理解加以提炼翻译过来的，英文水平有限，出现问题请指正。想看原版完整文档的同学可以点击上面的链接。 一. 本书内容 传统的计算机算法在解决问题的时候，通常都是由程序员制定好规则将问题进行分解，一步步进行解决。应用神经网络我们一般并不需要告诉计算机应该怎么去解决问题，而是只要给到足够的观测数据就可以了，它将会自动从这些数据中提取出解决方法。 本书主要的目的是帮助读者掌握包括深度学习相关技术在内的神经网络领域的核心知识。在掌握了本书内容后，可以使用深度学习模型解决遇到的问题，更进一步可以设计自己的神经网络用以解决特定的问题。 当然这本书也不会完全是理论知识，作者通过“手写数字识别“这个常见但是普通编程方法很难解决的问题介绍了神经网络的基本知识。通过这本书，他还基于python一步一步实现了一个简单的神经网络库，使得大家在接触到其他新的神经网络库的时候也能很快的理解并读懂代码。 二. 手写字体识别 对于这样一副图片，人脑很容易就能识别出来其中的数字。但是对于计算机就没有这么容易了，按照以前老的解决问题的思路，就是规则的堆砌，比如说“上部分有个圈，右下方有条垂直线，这个数字就是9”，很显然，对于手写字体这样肯定是不切实际的。因为手写数字太不规范了 …" />
<meta property="og:site_name" content="Shangzhi HUANG&#39;s Blog" />
<meta property="og:article:author" content="Shangzhi HUANG" />
<meta property="og:article:published_time" content="2017-08-23T20:00:00+08:00" />
<meta name="twitter:title" content="《深度学习与神经网络》笔记1  - 使用神经网络识别手写数字 ">
<meta name="twitter:description" content="深度学习算是现在机器学习领域非常热门的方向了，虽然一直有了解并且简单用过，但是对于其中的详细原理和来龙去脉都是略知一二，于是一直想系统学习一下该领域的相关知识。《Neural Networks and Deep Learning》是一份非常好的入门材料，讲解详细而且不光是介绍了理论知识，更重要的是介绍了每一步的来龙去脉以及为什么要这样做。在线文档是英文版的，我这份总结笔记的很大部分是结合原文根据自己的理解加以提炼翻译过来的，英文水平有限，出现问题请指正。想看原版完整文档的同学可以点击上面的链接。 一. 本书内容 传统的计算机算法在解决问题的时候，通常都是由程序员制定好规则将问题进行分解，一步步进行解决。应用神经网络我们一般并不需要告诉计算机应该怎么去解决问题，而是只要给到足够的观测数据就可以了，它将会自动从这些数据中提取出解决方法。 本书主要的目的是帮助读者掌握包括深度学习相关技术在内的神经网络领域的核心知识。在掌握了本书内容后，可以使用深度学习模型解决遇到的问题，更进一步可以设计自己的神经网络用以解决特定的问题。 当然这本书也不会完全是理论知识，作者通过“手写数字识别“这个常见但是普通编程方法很难解决的问题介绍了神经网络的基本知识。通过这本书，他还基于python一步一步实现了一个简单的神经网络库，使得大家在接触到其他新的神经网络库的时候也能很快的理解并读懂代码。 二. 手写字体识别 对于这样一副图片，人脑很容易就能识别出来其中的数字。但是对于计算机就没有这么容易了，按照以前老的解决问题的思路，就是规则的堆砌，比如说“上部分有个圈，右下方有条垂直线，这个数字就是9”，很显然，对于手写字体这样肯定是不切实际的。因为手写数字太不规范了 …">

        <title>《深度学习与神经网络》笔记1  - 使用神经网络识别手写数字  · Shangzhi HUANG&#39;s Blog
</title>
        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet">
        <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.1/css/font-awesome.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="/theme/css/pygments.css" media="screen">
        <link rel="stylesheet" type="text/css" href="/theme/tipuesearch/tipuesearch.css" media="screen">
        <link rel="stylesheet" type="text/css" href="/theme/css/elegant.css" media="screen">
        <link rel="stylesheet" type="text/css" href="/theme/css/custom.css" media="screen">
        <link rel="shortcut icon" href="/theme/images/favicon.ico" type="image/x-icon" type="image/png" />
        <link rel="icon" href="/theme/images/apple-touch-icon-152x152.png" type="image/png" />
        <link rel="apple-touch-icon" href="/theme/images/apple-touch-icon.png"  type="image/png" />
        <link rel="apple-touch-icon" sizes="57x57" href="/theme/images/apple-touch-icon-57x57.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="72x72" href="/theme/images/apple-touch-icon-72x72.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="76x76" href="/theme/images/apple-touch-icon-76x76.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="114x114" href="/theme/images/apple-touch-icon-114x114.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="120x120" href="/theme/images/apple-touch-icon-120x120.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="144x144" href="/theme/images/apple-touch-icon-144x144.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="152x152" href="/theme/images/apple-touch-icon-152x152.png" type="image/png" />
        <link href="/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="Shangzhi HUANG&#39;s Blog - Full RSS Feed" />
    </head>
    <body>
        <div id="content-sans-footer">
        <div class="navbar navbar-static-top">
            <div class="navbar-inner">
                <div class="container-fluid">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" href="/"><span class=site-name>Shangzhi HUANG's Blog</span></a>
                    <div class="nav-collapse collapse">
                        <ul class="nav pull-right top-menu">
                            <li ><a href="/">Home</a></li>
                            <li ><a href="/categories.html">Categories</a></li>
                            <li ><a href="/tags.html">Tags</a></li>
                            <li ><a href="/archives.html">Archives</a></li>
                            <li><form class="navbar-search" action="/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span1"></div>
                <div class="span10">
<article>
<div class="row-fluid">
    <header class="page-header span10 offset2">
    <h1><a href="/shen-du-xue-xi-yu-shen-jing-wang-luo-bi-ji-1.html"> 《深度学习与神经网络》笔记1  <small> 使用神经网络识别手写数字 </small>  </a></h1>
    </header>
</div>

<div class="row-fluid">
    <div class="span2 table-of-content">
        <nav>
        <h4>Contents</h4>
        <div class="toc">
<ul>
<li><a href="#_1">一. 本书内容</a></li>
<li><a href="#_2">二. 手写字体识别</a></li>
<li><a href="#_3">三. 感知机</a></li>
<li><a href="#sigmoid">四. Sigmoid神经元</a><ul>
<li><a href="#_4">练习</a></li>
</ul>
</li>
<li><a href="#_5">五. 神经网络的结构</a></li>
<li><a href="#_6">六. 一个用于手写数字识别的简单神经网络</a><ul>
<li><a href="#_7">练习</a></li>
</ul>
</li>
<li><a href="#_8">七. 梯度下降学习算法</a><ul>
<li><a href="#_9">练习</a></li>
<li><a href="#_10">练习</a></li>
</ul>
</li>
<li><a href="#_11">八. 数字识别神经网络的实现</a><ul>
<li><a href="#_12">练习</a></li>
<li><a href="#_13">练习</a></li>
</ul>
</li>
<li><a href="#_14">九. 关于深度学习</a></li>
</ul>
</div>
        </nav>
    </div>
    <div class="span8 article-content">

            
            
<p>深度学习算是现在机器学习领域非常热门的方向了，虽然一直有了解并且简单用过，但是对于其中的详细原理和来龙去脉都是略知一二，于是一直想系统学习一下该领域的相关知识。<a href="http://neuralnetworksanddeeplearning.com/about.html">《Neural Networks and Deep Learning》</a>是一份非常好的入门材料，讲解详细而且不光是介绍了理论知识，更重要的是介绍了每一步的来龙去脉以及为什么要这样做。在线文档是英文版的，我这份总结笔记的很大部分是结合原文根据自己的理解加以提炼翻译过来的，英文水平有限，出现问题请指正。想看原版完整文档的同学可以点击上面的链接。</p>
<h2 id="_1">一. 本书内容</h2>
<p>传统的计算机算法在解决问题的时候，通常都是由程序员制定好规则将问题进行分解，一步步进行解决。应用神经网络我们一般并不需要告诉计算机应该怎么去解决问题，而是只要给到足够的观测数据就可以了，它将会自动从这些数据中提取出解决方法。</p>
<p>本书主要的目的是帮助读者掌握包括深度学习相关技术在内的神经网络领域的核心知识。在掌握了本书内容后，可以使用深度学习模型解决遇到的问题，更进一步可以设计自己的神经网络用以解决特定的问题。</p>
<p>当然这本书也不会完全是理论知识，作者通过“手写数字识别“这个常见但是普通编程方法很难解决的问题介绍了神经网络的基本知识。通过这本书，他还基于python一步一步实现了一个简单的神经网络库，使得大家在接触到其他新的神经网络库的时候也能很快的理解并读懂代码。</p>
<h2 id="_2">二. 手写字体识别</h2>
<p><img alt="" src="./images/sdxxsjwl11.png"/></p>
<p>对于这样一副图片，人脑很容易就能识别出来其中的数字。但是对于计算机就没有这么容易了，按照以前老的解决问题的思路，就是规则的堆砌，比如说“上部分有个圈，右下方有条垂直线，这个数字就是9”，很显然，对于手写字体这样肯定是不切实际的。因为手写数字太不规范了，不同人的写法不一样，很多规则并不通用，通过制定精确的规则来解决这个问题的可行性微乎其微。</p>
<p>神经网络则不一样，它能够从训练数据自动提炼出可以识别不同数字的“规则”，增加训练数据量的话，这样的识别结果通常就会更加准确。在这章的最后，我们会实现一个简单的神经网络程序，虽然代码量不多，但是却可以取得不错的96%的准确率。在随后的章节，我们会逐步优化我们的神经网络，使它可以取得高达99%的准确率。</p>
<p>手写数字识别问题很经典，不难理解，而且计算量也不大，在本书的最后，我们也会讨论一下怎么讲在这个问题上获得的思想应用到其他的领域。</p>
<p>这章的重点当然不仅仅是实现神经网络代码，我们将会了解到很多重要的神经网络基本概念，包括两种最重要的神经元（感知机和sigmoid），神经网络模型最基本的学习算法（随即梯度下降算法）。作者通过大段的讨论着重讲解为什么要这样做，培养大家对于神经网络的直觉，使读者可以对神经网络有更深的理解，为后续理解深度学习打下扎实基础。</p>
<h2 id="_3">三. 感知机</h2>
<p>最简单的感知机模型如下：</p>
<p><img alt="" src="./images/sdxxsjwl12.png"/></p>
<p>其中<span class="math">\(x_1, x_2, x_3...\)</span>为模型的输入，可以是0或1的非数值型变量，也可以是数值型变量，其中每个输入维度上都有对应的一个权重<span class="math">\(w_1, w_2, w_3\)</span>，模型的输出是由<span class="math">\(\sum_jw_jx_j\)</span>与阈值的大小关系决定的，等价于公式：</p>
<div class="math">$$output = \left\{\begin{aligned}  0 &amp;\quad if \sum_jw_jx_j \leqslant threshold \\ 1 &amp;\quad if \sum_jw_jx_j &gt; threshold \end{aligned}\quad(1)\right.$$</div>
<p>通过这个公式可以看到，感知机的作用很简单，就是对输入进行加权求和，然后和阈值对比。比阈值大，表示这个神经元受到激发了，输出1，否则输出0，这样就相当于实现了一个简单二分类器。</p>
<p>当然这样简单的一个神经元肯定无法满足我们的需求，通常的神经网络都是有许多个神经元组合而成的网状结构，类似下图这样的：</p>
<p><img alt="" src="./images/sdxxsjwl13.png"/></p>
<p>这里的输入是以箭头的形式表示的，通常我们是将其表示为一个特殊的神经元：</p>
<p><img alt="" src="./images/sdxxsjwl14.png"/></p>
<p>该神经元没有输入，只有一个固定的输出就等价于上面input中的一个维度。</p>
<p>其次这个神经网络是多层的，上一层的输出作为下一层的输入。注意到，每个神经元其实只有一个输出，但是上面图里面有些神经元却有多个输出箭头，这其实是为了直观的表示这个神经元的输出会作为后一层多个神经元的输入，也就是被使用了多次。</p>
<p>除此之外，我们通常的表示方法并不使用上文中阈值的表达形式，而是使用类似于回归分析中的intercept的表达形式。我们设定<span class="math">\(bias\)</span>，<span class="math">\(b = -threshold\)</span>，这样的话公式（1）就可以被写为</p>
<div class="math">$$output = \left\{\begin{aligned}  0 &amp;\quad if w*x+b \leqslant 0 \\ 1 &amp;\quad if w*x + b &gt; 0 \end{aligned}\quad(2)\right.$$</div>
<p>其中<span class="math">\(bias\)</span>可以理解为表示该神经元被激发的难易程度，<span class="math">\(bias越大\)</span>，越容易被激发。</p>
<h2 id="sigmoid">四. Sigmoid神经元</h2>
<p>在介绍第二种重要的神经元sigmoid之前，我们先讲一下学习算法的设计思路。假设我们现在有一个用来解决手写数字识别问题的基于感知机的神经网络，输入是手写图片展开后的特征向量，输出是识别的数字，但是其中的参数（weights和bias）是未知的。我们想做的就是通过学习获得合适的参数使得这个网络能够正确的区分手写数字。</p>
<p>为了理解学习算法是怎么进行的，假设我们对一些weight或者bias引入很小的变化，使得这些小变化会对神经网络的输出也产生对应的很小的变化，如下图所示：</p>
<p><img alt="" src="./images/sdxxsjwl15.png"/></p>
<p>基于这样的假设，我们可以逐步的调整参数使得神经网络可以朝着我们需要的方向进行优化，也就是说它对手写数字的识别越来越准确。例如，在学习过程中，神经网络将“9”错分为“8”，我们可以稍微调整weights和biases使得它更偏向于将这个“9”正确分为“9”。我们重复这样的步骤，直到模型对数字的识别越来越准确。</p>
<p>但是由于感知机的输出非0即1，任何一个感知机的参数的细微变化都有可能导致该感知机的输出在0，1上不停的跳变，这样就会导致后续的网络结构的输出可能产生非常大的变化。也就是说，可能这个“9”模型正确识别了，却会导致其他数字的识别发生非常大的改变，这样就导致我们的算法很难收敛，很难通过逐渐改变参数进行优化这样的方法去得到一个稳定的准确的模型。</p>
<p>通过引入sigmoid神经元就可以克服这个问题。sigmoid神经元和感知机类似，但是不同的是，修改它的参数对输出只会造成很小的影响，不会出现0到1这样截然不同的变化，因为sigmoid函数是一个连续可导的函数。</p>
<p>sigmoid函数：</p>
<div class="math">$$\sigma(z)=\frac{1}{1+e^{-z}}\quad(3)$$</div>
<p>代入输入<span class="math">\(x_1,x_2,...,\)</span>,权重<span class="math">\(w_1,w_2,...\)</span>和偏差<span class="math">\(b\)</span>，上式可以写为：</p>
<div class="math">$$\frac{1}{1+exp(-\sum_jwjxj-b)}\quad (4)$$</div>
<p>虽然从公式上看感知机和sigmoid貌似相差很多，但其实它们两者有很多相同点，为了理解这些，我们假设<span class="math">\(z=w*x+b\)</span>,当<span class="math">\(z\rightarrow+\infty\)</span>时，有<span class="math">\(e^{-z}\approx 0\)</span>和<span class="math">\(\sigma(z)\approx 1\)</span>,sigmoid函数达到最大值。另一方面，当<span class="math">\(z\rightarrow-\infty\)</span>时，有<span class="math">\(e^{-z}\approx +\infty\)</span>和<span class="math">\(\sigma(z)\approx 0\)</span>,sigmoid函数达到最小值，这两种特殊情况都是等价于感知机的情形的。sigmoid和感知机的不同发生在<span class="math">\(z=w*x+b\)</span>值较小的情况，通过它们的函数图像可以更直观的看到这点。</p>
<p><img alt="" src="./images/sdxxsjwl16.png"/></p>
<p>感知机的激活函数是一个阶跃函数：</p>
<p><img alt="" src="./images/sdxxsjwl17.png"/></p>
<p>可以看到感知机的激活函数在0处是不可导的，而sigmoid可以看作是一个平滑版的感知机，它的函数处处可导连续。sigmoid函数的平滑性意味着参数的细微改变<span class="math">\(\Delta w_j\)</span>和<span class="math">\(\Delta b\)</span>会对输出产生一个细微的变化<span class="math">\(\Delta output\)</span>， 利用微分的概念可以近似得到</p>
<div class="math">$$\Delta output \approx \sum_j\frac{\partial output}{\partial w_j}\Delta w_j+\frac{\partial output}{\partial b}\Delta b\quad (5)$$</div>
<p>上面的式子看起来有点复杂，但是它表明一个简单的事实，就是<span class="math">\(\Delta output\)</span>和参数改变量<span class="math">\(\Delta w_j\)</span>和<span class="math">\(\Delta b\)</span>的线形联系。这就使得我们可以很容易的找到合适的参数变化量来实现我们需要的在输出值上的改变。</p>
<p>在后面的章节中，我们会看到sigmoid也只是众多激活函数中的一种，还存在其他很多合适的激活函数，但是目前来说这些都不重要。对于我们的公式（5）来说，改变激活函数只是在改变它对于变量的偏导数，并不影响我们对于流程的理解。我们先讲解sigmoid函数只是指数函数在求导时的简洁属性，而且sigmoid也是使用最广泛的激活函数。</p>
<p>不像感知机的输出0和1，能够很直接的表示一个数字是与否，sigmoid函数的输出是[0,1]区间上的连续实数，但是注意到<span class="math">\(\sigma(z)\)</span>关于<span class="math">\(z\)</span>在<span class="math">\((0,0.5)\)</span>处是一个非常完美的中心对称形式，我们很容易想到用0.5作为判断sigmoid函数输出的阈值，例如当其输出不小于0.5时表示“9”，小于0.5时表示它不是“9”。熟悉逻辑回归的话，也能想到[0，1]的值域还可以当作是一个概率空间。</p>
<h3 id="_4">练习</h3>
<p>问题一：</p>
<p>对于一个感知机网络，假设我们把它所有的<span class="math">\(w_j\)</span>和<span class="math">\(b\)</span>同时乘上一个正数<span class="math">\(c&gt;0\)</span>，证明这个感知机网络并没有改变。</p>
<p>答案：</p>
<p>感知机的激活函数为比较<span class="math">\(\sum_jw_jx_j+b\)</span>和0的大小（大于0输出1，小于0输出0），乘以一个正数<span class="math">\(c\)</span>以后，<span class="math">\(\sum_jcw_jx_j+cb = c(\sum_jw_jx_j+b)\)</span>，并不影响它跟0的相对大小关系，当然也不会影响感知机的输出。</p>
<p>问题二：</p>
<p>对于一个感知机网络，对于给定的输入<span class="math">\(x\)</span>，假设对于其中每个感知机神经元都有<span class="math">\(w*x+b\neq 0\)</span>.假如我们把所有的感知机神经元替换成sigmoid神经元，然后将所有<span class="math">\(w_j\)</span>和<span class="math">\(b\)</span>乘一个正数<span class="math">\(c&gt;0\)</span>。证明当<span class="math">\(c\rightarrow+\infty\)</span>时，这些sigmoid模型等价于感知机模型，如果存在一个神经元对当前输入有<span class="math">\(w*x+b=0\)</span>呢？</p>
<p>答案：</p>
<p>首先我们知道根据公式(2),感知机的输出为0和1，对于任意sigmoid函数，有<span class="math">\(\frac{1}{1+exp(-c*wx-c*b)}=\frac{1}{1+exp(c*(-wx-b))}\)</span>，然后如果<span class="math">\(wx+b&gt;0\)</span>，由于<span class="math">\(c\rightarrow +\infty\)</span>,则有<span class="math">\(\sigma \rightarrow \frac{1}{1+0}=1\)</span>，如果<span class="math">\(wx+b&lt;0\)</span>，则有<span class="math">\(\sigma \rightarrow \frac{1}{1+\infty}=0\)</span>,和感知机模型的行为一样！显然如果<span class="math">\(wx+b=0\)</span>，则没有这样的结论，因为<span class="math">\(\sigma = \frac{1}{1+1} = 0.5\)</span>和感知机情形不符合。</p>
<h2 id="_5">五. 神经网络的结构</h2>
<p>下一节中，我们将会引入一个处理手写数字识别的神经网络，但在这之前，我们先解释神经网络中常用的一些概念。对于这样一个神经网络：</p>
<p><img alt="" src="./images/sdxxsjwl18.png"/></p>
<p>其中最左边的一层被称为输入层，最右边的一层称为输出层，其中中间的一层是隐藏层，这里只有一层隐藏层，但是隐藏层是可以有很多层的。</p>
<p>输入层和输出层的结构通常可以根据具体问题直接得到。比如说我们要判断一副手写数字图片表示的是“9”还是不是。最简单的方法，就是把图片的像素展开为一维向量，也就是对于64*64=4096的图片，输入层就是4096个神经元，输出层只有一个神经元，因为只要判断是否是“9”。</p>
<p>但是对于隐藏层就没有这么简单了，通常很难总结出设计隐藏层的通用方法。于是神经网络研究者就通过启发式的方法开发了许多隐藏层的设计。比如，一些启发式的想法就是通过考虑神经网络的训练时间来权衡隐藏层的数量。我们将在本书的后面见到其他的一些启发式的设计。</p>
<p>到目前为止，我们讨论的神经网络都是上一层的输出作为后一层的输入。这种神经网络也被称为前馈（feedback）神经网络，意味着在这种网络中不存在循环结构。输出不能通过反馈影响到输入。</p>
<p>然而也有存在含有反馈的循环神经网络（recurrent neural networks RNN）。这种模型的设计是考虑到一个神经元受到激发后，激发状态并不会随着输入的改变而立刻变化，而是会存在一段时间，通过反馈影响到输入。（RNN的详细情况，我目前也不是很清楚，以后再专门介绍一下。）</p>
<p>RNN相对于前馈神经网络来说应用没有那么广泛，对于RNN的学习算法不够成熟。但是RNN还是非常有意义的，因为相对于前馈神经网络来说，它更符合我们人脑的行为。不过，本书还是更关注前馈神经网络多一点。</p>
<h2 id="_6">六. 一个用于手写数字识别的简单神经网络</h2>
<p>在定义了神经网络后，我们回到手写数字识别这个问题上。实际中，这个问题其实包含两个字问题，(1)对一串数字进行分割成一个一个的数字，也就是说确定一串数字中，数字与数字之间的边界。(2)对每个分割出的数字进行判断，识别出它表示哪个数字。</p>
<p>第一个问题不是我们的重点，我们主要关注第二个问题，而且我们的训练数据MNIST也是分割好的数字，一张图片就是一个数字。 为了解决这样一个识别问题，我们使用一个三层的神经网络：</p>
<p><img alt="" src="./images/sdxxsjwl19.png"/></p>
<p>由于MNIST数据都是28*28=784的图片，所以这里我们使用的神经网络的输入层也有784个神经元组成（图中只画出了部分），每个维度输入值的都是该像素点的灰度值，0表示白，1表示黑，0到1之间的小数表示不能灰度的灰色。</p>
<p>第二层为网络的隐藏层，我们定义它包含<span class="math">\(n\)</span>个神经元，我们将会测试不同的<span class="math">\(n\)</span>找出最佳的结构。图中的例子显示的是一个比较小的隐藏层结构，只有<span class="math">\(n=15\)</span>个神经元。</p>
<p>输出层由10个神经元组成，显然对应的是0-9的10个数字。假如第一个神经元被激发，输出1，表示这个数字是0，第二个神经元被激发则表示是1，以此类推。具体的说，它们的输出是[0，1]上的实数，可能会出现多个神经元被激发的情况，我们取输出最大的那个神经元代表的数字作为输出结果。</p>
<p>可能有人会有疑问，是不是只需要四个神经元就够了，因为类似于二进制编码，<span class="math">\(2^4=16&gt;10\)</span>，四个神经元就足够可以表示10种不同的情形了。为什么我们要用10个呢？这样是不是显得效率不够高？其实最终作出使用10个神经元的决定也是经验性的，我们可以尝试不同的结构，最后发现，对于这个问题，10个神经元作为输出层的模型要好于4个神经元作为输出层的模型。</p>
<p>但是为什么会出现这样的情况呢？是否存在直觉能提前告诉我们，我们应该使用10个而不是4个吗？</p>
<p>为了理解为什么这样做，我们思考一下这里神经网络是怎么运行的。先考虑使用10个神经元的输出。对于第一个输出神经元，也就是决定数字是否为0的那个输出神经元，它所做的是对隐藏层的输出结果进行加权求和。那么隐藏层呢，设想隐藏层第一个神经元是为了检测图片中是否含有这样的模式：</p>
<p><img alt="" src="./images/sdxxsjwl110.png"/></p>
<p>这个神经元可以通过对这些区域的像素点给予大的权重，而对其他区域的像素点给予小的权重实现这样的功能。同样的，设想隐藏层中的第二个，第三个，第四个神经元分别可以检测下面这些图片特征：</p>
<p><img alt="" src="./images/sdxxsjwl111.png"/></p>
<p>可以看到，这个例子，也就是这四个特征刚好组成了0这个数字：</p>
<p><img alt="" src="./images/sdxxsjwl112.png"/></p>
<p>所以如果这几个隐藏层的神经元都被激发的话，我们就可以判断这个数字是0了。当然，我们判断是0的特征并不是只有这些，实际中0的写法也是多种多样的。</p>
<p>这样的话似乎解释了为什么使用10个输出神经元比4个输出神经元效果好。因为假如用4个输出的话，就不大好将数字的特征和最终的输出联系起来。</p>
<p>不过这其实也是一种启发式的想法。并没有什么证据证明这个三层的神经网络必须按照这种方式进行数字的识别：一个隐藏神经元识别图像的一部分特征形状。也许会存在更好的学习算法使得4个神经元输出的神经网络一样可以达到很好的效果。</p>
<h3 id="_7">练习</h3>
<p>如下图所示，通过在原有三层神经网络的基础上再加上一个新的由四个神经元组成的输出层，就可以实现数字的二进制表达形式的输出，假设这个三层神经网络识别准确度非常高，也就是正确数字所在的神经元的激活值不小于0.99，其他神经与激活值小于0.01，试找出最后一层的weights和bias</p>
<p><img alt="" src="./images/sdxxsjwl113.png"/></p>
<p>答案：</p>
<p>这个题目答案并不唯一，考虑到可以这样：</p>
<p><span class="math">\(0\rightarrow 0001, 1\rightarrow 0010, 2\rightarrow 0011...\)</span>，然后发现最后一层第一个神经元为1的时候对应的数字有7，8，9，第二神经元位1的时候对应的数字有3，4，5，以此类推。然后按照这些规律把对应有联系的地方的权重设置为1，没联系的可以设置为0，再稍微调节bias就可以了，这里就不具体算了。</p>
<h2 id="_8">七. 梯度下降学习算法</h2>
<p>在设计好了我们的神经网络之后，它怎样才能识别数字呢？首先需要通过训练集进行学习。这里我们使用MNIST数据集。MNIST大家应该都了解过，都是28*28=784像素的图片。</p>
<p>这里我们定义训练输入为<span class="math">\(x\)</span>，长度为784的一维向量。定义<span class="math">\(y=y(x)\)</span>为输入为<span class="math">\(x\)</span>下正确的输出，是一个10维的向量。例如：对于数字为6的一副图片，<span class="math">\(y(x) = (0,0,0,0,0,0,1,0,0,0)^T\)</span>.</p>
<p>我们想要的是算法可以帮我们找到合适的weights和biases使得我们神经网络的输出可以尽可能的接近它的真实值。定义一个损失函数：</p>
<div class="math">$$C(w, b) = \frac{1}{2n}\sum_x||y(x)-a||^2\quad (6)$$</div>
<p>这里<span class="math">\(w\)</span>表示所有权重，<span class="math">\(b\)</span>表示所有偏差，<span class="math">\(n\)</span>是训练数据集的大小，<span class="math">\(a\)</span>是输入为<span class="math">\(x\)</span>时我们的神经网络的输出。我们的目的就是找到合适的参数使损失函数的值尽量小。我们选择这个二次损失函数，而不是考虑正确分类的数量主要是因为这个函数是平滑的，连续可导。我们随后也会做一些调整，使用其他的平滑函数。</p>
<p>为了解决这个最小化的问题，接下来先介绍梯度下降算法。</p>
<p>假设我们想要最下华函数<span class="math">\(C(v)\)</span>，函数的参数是<span class="math">\(v=v_1,v_2,...\)</span>当然这些参数可以是任意的，为了直观表现我们假设有两个参数，图像如下：</p>
<p><img alt="" src="./images/sdxxsjwl114.png"/></p>
<p>这个函数图像很简单，直接就能看出来就是曲面的谷底就是最小值所在的地方。但是实际的情况很定存在很多各种各样非常复杂的函数，不能都能靠肉眼就能直接找出最小值。</p>
<p>另一种方法就是用解析的方法去对函数求导，然后再去求导数为0的解析解，也就是函数极值所在的地方。这个看上去很完美，因为找到的可以是全局的最优解，但是实际情况是函数过于复杂，或者变量非常多，根本就没法找到解析解，这种方法实际上是不可行的。</p>
<p>那就换个思路，类似于上图中那样，我们把函数想象成一个山谷。我们有一个球在山谷里滚动，慢慢的就会滚落到谷底了，也就是函数的极值点。也就是说，我们假设一个初始点，让这个点模仿这个球的运动在函数上移动，然后就可以找到这样的极值点了。</p>
<p>要实现这样的目的，我们就可以对函数求导，函数的导数值就可以表明这个山谷每处的形状，是上升的还是下降的还是平的，对应的就是导数值大于0，小于0，等于0的地方。</p>
<p>假设我们让球沿着<span class="math">\(v_1\)</span>方向移动<span class="math">\(\Delta v_1\)</span>,沿着<span class="math">\(v_2\)</span>方向移动<span class="math">\(\Delta v_2\)</span>。我们得到函数<span class="math">\(C\)</span>的值的变化为</p>
<div class="math">$$\Delta C \approx \frac{\partial C}{\partial v_1}\Delta v_1 + \frac{\partial C}{\partial v_2}\Delta v_2 \quad (7)$$</div>
<p>因为我们的目的是找到<span class="math">\(C\)</span>的最小值，当然就希望每次的<span class="math">\(\Delta C\)</span>是负值。设<span class="math">\(\Delta v = (\Delta v_1, \Delta v_2)^T\)</span>,定义函数<span class="math">\(C\)</span>在方向<span class="math">\(v_1,v_2\)</span>上的梯度为</p>
<div class="math">$$\bigtriangledown C= (\frac{\partial C}{\partial v_1}, \frac{\partial C}{\partial v_2})^T \quad (8)$$</div>
<p>.</p>
<p>于是我们可以将公式(7)改写为：</p>
<div class="math">$$\Delta C \approx \bigtriangledown C * \Delta v\quad (9)$$</div>
<p>这个公式也解释了为什么将<span class="math">\(\bigtriangledown C\)</span>称为梯度向量，它联系了<span class="math">\(v\)</span>的变化与<span class="math">\(C\)</span>的变化。</p>
<p>接下来回到上面我们的问题，怎么移动<span class="math">\(v\)</span>，也就是怎么对<span class="math">\(\Delta v\)</span>取值，才能保证<span class="math">\(\Delta C\)</span>是负数。不妨取</p>
<div class="math">$$\Delta v = -\eta \bigtriangledown C\quad (10)$$</div>
<p>其中<span class="math">\(\eta\)</span>是一个很小的正数（通常被称为学习率）。然后<span class="math">\(\Delta C \approx -\eta\bigtriangledown C \cdot \bigtriangledown C = -\eta||\bigtriangledown C||^2\)</span>,这就可以保证<span class="math">\(\Delta C\leqslant 0\)</span>, <span class="math">\(C\)</span>就可以朝着减小的方向一直优化下去。公式(10)即是我们需要的"运动规则"，我们每次将位置为<span class="math">\(v\)</span>的小球移动到：</p>
<div class="math">$$v \rightarrow v' = v - \eta \bigtriangledown C \quad (11)$$</div>
<p>总的来说，梯度下降算法，就是我们不停的计算当前位置的梯度<span class="math">\(\bigtriangledown C\)</span>, 然后朝着相反的方向移动，直到下降到谷底，类似于下图：</p>
<p><img alt="" src="./images/sdxxsjwl115.png"/></p>
<p>当然梯度下降并不是真实的物理运动，现实中，运动是存在惯性的，以后也会看到有的时候我们也会模拟惯性去解决局部最优的问题。不过这里，我们的选择就是一路朝的低谷运动，到了就停下，不考虑惯性的影响。</p>
<p>学习率<span class="math">\(\eta\)</span>的选择对算法有着很重要的影响，<span class="math">\(\eta\)</span>必须足够小才能使公式(9)近似成立，如果<span class="math">\(\eta\)</span>过大的话会导致<span class="math">\(\Delta C&gt;0\)</span>，而如果过小的话，又会导致每次梯度下降的过于缓慢。所以实际中，<span class="math">\(\eta\)</span>是一个变量使得公式(9)成立，并且算法的效率可以接受。</p>
<p>上面介绍2维的情形只是方便从图像上进行直观的理解，我们可以很容易的将其推广到多维的情形。假设<span class="math">\(C\)</span>是关于<span class="math">\(m\)</span>个变量<span class="math">\(v_1,v_2,...,v_m\)</span>的函数，于是有</p>
<div class="math">$$\Delta C \approx \bigtriangledown C\cdot \Delta v \quad (12)$$</div>
<p>，类似于2维的情形，其中<span class="math">\(\Delta v = (\Delta v_1, ..., \Delta v_m)^T\)</span>, 梯度<span class="math">\(\bigtriangledown C\)</span>为：</p>
<div class="math">$$\bigtriangledown C = (\frac{\partial C}{\partial v_1},...,\frac{\partial C}{\partial v_m})^T \quad (13)$$</div>
<p>然后我们选择</p>
<div class="math">$$\Delta v = -\eta \bigtriangledown C \quad (14)$$</div>
<p>每次<span class="math">\(v\)</span>的变化如下</p>
<div class="math">$$v \rightarrow v' = v - \eta \bigtriangledown C \quad (15)$$</div>
<p>这个公式也可以被认为是梯度下降算法的定义，它提供了一种迭代的改变<span class="math">\(v\)</span>的位置去寻找最小值的方法。但是它无法保证总能找到全局最小值，后面的章节会讨论这点。</p>
<p>梯度下降算法寻找最小值的优化策略还有另外一种理解方式。假设现在需要在某个方向上移动<span class="math">\(\Delta v\)</span>使得<span class="math">\(C\)</span>可以减小最多。因为<span class="math">\(\Delta C\)</span>是负数，所以等价于最小化<span class="math">\(\Delta C \approx \bigtriangledown C \cdot \Delta v\)</span>，假设每次移动的距离为一个固定值<span class="math">\(||\Delta v||=\epsilon&gt;0\)</span>,能够证明当<span class="math">\(\Delta v = -\eta \Delta C\)</span>,其中<span class="math">\(\eta = \epsilon / ||\bigtriangledown C||，||\Delta v||=\epsilon\)</span>时，<span class="math">\(\bigtriangledown C \cdot \Delta v\)</span>达到最小值。于是梯度下降可以被认为是不断的朝着使得该位置<span class="math">\(C\)</span>处减小最多的方向移动一个很小的距离的过程。</p>
<h3 id="_9">练习</h3>
<p>问题一：</p>
<p>证明上面最后一段中梯度下降算法的另一种描述。提示：柯西不等式</p>
<p>答案：</p>
<p>这里其实用不用柯西不等式无所谓，根据高中数学也能理解，两个向量相乘，如果向量的模都是固定值的话，当这两个向量方向相反的时候，乘积最小。</p>
<p><span class="math">\(\Delta C \approx \bigtriangledown C \cdot \Delta v = ||\bigtriangledown C|| \cdot ||\Delta v|| \cdot cos\theta\)</span> 其中<span class="math">\(cos\theta\)</span>是两个向量的夹角的余弦值，而且<span class="math">\(||\bigtriangledown C||\)</span>和<span class="math">\(||\Delta v||\)</span>是固定值所以当<span class="math">\(cos\theta = -1\)</span>时，值最小，此时有两个向量方向相反，即<span class="math">\(\frac{\Delta v}{||\Delta v||} = -\frac{\bigtriangledown C}{||\bigtriangledown C||}\)</span>,于是有<span class="math">\(\Delta v = -||\Delta v||\cdot \frac{\bigtriangledown C}{||\bigtriangledown C||} = -\epsilon \cdot \frac{\bigtriangledown C}{||\bigtriangledown C||} = -\eta \bigtriangledown C\)</span>其中<span class="math">\(\eta = \epsilon/||\bigtriangledown C||\)</span></p>
<p>问题二：</p>
<p>作者解释了梯度下降算法在二维和多维的情形，给出在一维情形下类似的定义</p>
<p>答案：</p>
<p>这个基本是一样了，无非二维是三维图上的最低点，一维就是二维图上的最低点，类似于一条二次曲线，最小值在导数为零的谷底，一维就是直接对自变量求导数，而多维是对每个自变量求偏导数获得梯度，迭代的过程中都是朝着导数的反方向移动。</p>
<p>梯度下降算法有很多变种，其中有些更接近真实的物理运动。但是通常情况下，这些算法需要计算<span class="math">\(C\)</span>对于各个自变量的二阶导数，这个运算是非常耗时的，于是便有了各种拟牛顿法等解决这类问题的技巧，不过作为一本入门书，本书中基本只使用梯度下降算法。</p>
<p>公式(15)应用到神经网络的学习中，得到如下公式：</p>
<div class="math">$$w_k \rightarrow w'_k = w_k - \eta \frac{\partial C}{\partial w_k}\quad (16)$$</div>
<div class="math">$$b_l \rightarrow b'_l = b_l - \eta \frac{\partial C}{\partial b_l} \quad (17)$$</div>
<p>然后不断地应用这个公式对神经网络的各个参数进行迭代直到达到停止条件。</p>
<p>让我们回到损失函数公式(6)，可以发现这个损失函数用到了所有的训练样本，求它们的损失的平均值。然后在求导数的时候，也会求平均值，即<span class="math">\(\bigtriangledown C = \frac{1}{n}\sum_x\bigtriangledown C_x\)</span>,即每次迭代都会用到所有的样本，当训练样本过大的时候，就会导致学习的过程非常漫长。</p>
<p>于是便产生了随机梯度下降(Stochastic gradient descent)这种算法。它的思想是在每次迭代过程求梯度的过程中只用到了随机选择的部分训练样本，达到加速训练的目的。</p>
<p>比如它每次随机选择<span class="math">\(m\)</span>个训练样本：<span class="math">\(X_1, X_2, ..., X_m\)</span>,称其为mini-batch。<span class="math">\(m\)</span>的选择通常是使<span class="math">\(\bigtriangledown C_{X_j}\)</span>和<span class="math">\(\bigtriangledown C_x\)</span>近似相等，即：</p>
<div class="math">$$\frac{\sum^m_{j=1}\bigtriangledown C_{X_j}}{m}\approx \frac{\sum_x\bigtriangledown C_x}{n} = \bigtriangledown C\quad (18)$$</div>
<div class="math">$$\bigtriangledown C \approx \frac{1}{m}\sum^m_{j=1}\bigtriangledown C_{X_j} \quad (19)$$</div>
<p>这样就保证了参数更新时的合理性。</p>
<p>于是公式(16),(17)就变成了</p>
<div class="math">$$w_k \rightarrow w'_k = w_k - \frac{\eta}{m} \sum_j\frac{\partial C_{X_j}}{\partial w_k} \quad (20)$$</div>
<div class="math">$$b_l \rightarrow b'_l = b_l - \frac{\eta}{m} \sum_j\frac{\partial C_{X_j}}{\partial b_l} \quad (21)$$</div>
<p>每次只使用了一次mini-batch中的<span class="math">\(m\)</span>个样本，当我们遍历玩所有训练样本的时候，相当于完成了一次epoch，需要的话，可以按照同样的方法进行下一次epoch。</p>
<p>注意到求不求平均其实影响不大，很多情况下前面的<span class="math">\(\frac{1}{n},\frac{1}{m}\)</span>并不会造成多大的影响，因为我们可以通过增大或者减小学习率来抵消掉影响。</p>
<p>随机梯度下降算法虽然会存在一定的统计上的波动，但是我们关心的只是下降的方向，并不是梯度的准确值。随机梯度下降算法在实际中是一种应用最为广泛神经网络的优化技术。</p>
<h3 id="_10">练习</h3>
<p>问题：</p>
<p>梯度下降的一个极端版本是采用大小为1的mini-batch。也就是说对每个训练样本都要更新一次模型参数。这种方式被称为online learning。说出这种方式与大小为2的mini-batch的随机梯度下降算法相比较的一个优点和一个缺点。</p>
<p>答案：</p>
<p>先说优点吧，online learning使用更为灵活，在数据量不足时不需要考虑冷启动的问题，而且每次更新模型只要考虑当前输入的一个样本，计算简单。而且模型无时无刻都在更新，因此可以处理复杂的真实情况。</p>
<p>缺点，我觉得可能是对异常值敏感，算法可能在有些情况不稳定。我也没怎么研究过这一块，不是很清楚。</p>
<h2 id="_11">八. 数字识别神经网络的实现</h2>
<p>接下来就是我们亲手去实现代码这块了，在此之前先把MNIST数据下载下来。</p>
<p><code>git clone https://github.com/mnielsen/neural-networks-and-deep-learning.git</code></p>
<p>不同于一开始说的60000张训练图片和10000张测试图片，我们将训练图片分为50000张训练集和10000张验证集。这一章我们先不用验证集，在后面的章节我们将使用它来选择“超参”。</p>
<p>先来看一下神经网络类的初始化代码：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">classNetwork</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> 
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sizes</span><span class="p">):</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">num_layers</span> <span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">sizes</span> <span class="o">=</span><span class="n">sizes</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">biases</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sizes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
</pre></div>
</td></tr></table>
<p>这里sizes是一个列表，包含了每一层的神经元个数。所以如果我们想要创建一个第一层油2个神经元，第二层有3个神经元，第三层有一个神经元的神经网络的话，可以这样调用构造函数：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">net</span> <span class="o">=</span> <span class="n">Network</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</td></tr></table>
<p>6，7行的代码是对参数进行初始化作为我们接下来梯度下降算法的开始点。注意到第一层没有进行bias的初始化，因为我们这里默认第一层是输入层，不需要bias。</p>
<p>注意到weights和biases都是由矩阵组成的list，例如net.weights[1]就是第二层到第三层神经元链接的权重。不妨定义该矩阵为<span class="math">\(w\)</span>，其中<span class="math">\(w_{jk}\)</span>表示第二层第k个神经元和第三层第j个神经元链接的权重。那么第三层的输出值向量为：</p>
<div class="math">$$a' = \sigma (wa+b)\quad (22)$$</div>
<p>其中a为第二层的输出。</p>
<h3 id="_12">练习</h3>
<p>问题：</p>
<p>给出公式(22)的分量形式</p>
<p>答案：</p>
<p>对于第三层中的第j个神经元，它的输出为：</p>
<div class="math">$$a'_j = \sigma (\sum^K_{k=1}(w_{jk} * a_k) + b_j)$$</div>
<p>其中K为第二层神经元的个数。</p>
<p>有了这些理解，很容易就能写出计算神经网络输出的代码：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">):</span> 
    <span class="k">return</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">))</span>
</pre></div>
</td></tr></table>
<p>随后是feedforward函数，用来在给定输入a的情况下，计算神经网络最终的输出：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">feedforward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span> 
<span class="c1">## Return the output of the network if "a" is input.</span>
    <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">biases</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">):</span> 
       <span class="n">a</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span><span class="o">+</span><span class="n">b</span><span class="p">)</span> 
    <span class="k">return</span> <span class="n">a</span>
</pre></div>
</td></tr></table>
<p>接下来就是算法学习的部分了，梯度下降算法的实现：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">SGD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">training_data</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">mini_batch_size</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">test_data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span> 
<span class="c1">## Train the neural network using mini-batch stochastic gradient descent. </span>
<span class="c1">## The "training_data" is a list of tuples "(x, y)" representing the training inputs and the desired outputs. </span>
<span class="c1">## The other non-optional parameters are self-explanatory. </span>
<span class="c1">## If "test_data" is provided then the network will be evaluated against the test data after each epoch, </span>
<span class="c1">## and partial progress printed out. This is useful for tracking progress, but slows things down substantially.</span>
    <span class="k">if</span> <span class="n">test_data</span><span class="p">:</span> 
        <span class="n">n_test</span> <span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">test_data</span><span class="p">)</span> 
        <span class="n">n</span> <span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">training_data</span><span class="p">)</span> 
        <span class="k">for</span> <span class="n">j</span> <span class="n">inxrange</span><span class="p">(</span><span class="n">epochs</span><span class="p">):</span> 
            <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">training_data</span><span class="p">)</span> 
            <span class="n">mini_batches</span> <span class="o">=</span><span class="p">[</span><span class="n">training_data</span><span class="p">[</span><span class="n">k</span><span class="p">:</span><span class="n">k</span><span class="o">+</span><span class="n">mini_batch_size</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="n">inxrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">mini_batch_size</span><span class="p">)]</span> 
            <span class="k">for</span> <span class="n">mini_batch</span> <span class="ow">in</span> <span class="n">mini_batches</span><span class="p">:</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">update_mini_batch</span><span class="p">(</span><span class="n">mini_batch</span><span class="p">,</span> <span class="n">eta</span><span class="p">)</span> 
            <span class="k">if</span> <span class="n">test_data</span><span class="p">:</span> 
                <span class="k">print</span> <span class="s2">"Epoch {0}: {1} / {2}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="mi">22</span> <span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">test_data</span><span class="p">),</span> <span class="n">n_test</span><span class="p">)</span> 
            <span class="k">else</span><span class="p">:</span> 
                <span class="k">print</span> <span class="s2">"Epoch {0} complete"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
</pre></div>
</td></tr></table>
<p>先看输入参数，有训练数据，epoch次数，mini-batch的大小，学习率eta，test_data控制是否需要在每次epoch后评价一下当前模型。</p>
<p>每次epoch时，现将训练数据打散分配到每个mini-batch起到随机抽样的效果，随后利用eta和当前mini-batch中的数据更新模型参数。这个更新过程就是梯度下降算法的更新过程：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">update_mini_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mini_batch</span><span class="p">,</span> <span class="n">eta</span><span class="p">):</span> 
    <span class="c1">## Update the network's weights and biases by applying gradient descent using backpropagation to a single mini batch. </span>
    <span class="c1">## The "mini_batch" is a list of tuples "(x, y)", and "eta" is the learning rate. </span>
    <span class="n">nabla_b</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">biases</span><span class="p">]</span> 
    <span class="n">nabla_w</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">]</span> 
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">mini_batch</span><span class="p">:</span> 
        <span class="n">delta_nabla_b</span><span class="p">,</span> <span class="n">delta_nabla_w</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">backprop</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> 
        <span class="n">nabla_b</span> <span class="o">=</span> <span class="p">[</span><span class="n">nb</span><span class="o">+</span><span class="n">dnb</span> <span class="k">for</span> <span class="n">nb</span><span class="p">,</span> <span class="n">dnb</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nabla_b</span><span class="p">,</span> <span class="n">delta_nabla_b</span><span class="p">)]</span> 
        <span class="n">nabla_w</span> <span class="o">=</span> <span class="p">[</span><span class="n">nw</span><span class="o">+</span><span class="n">dnw</span> <span class="k">for</span> <span class="n">nw</span><span class="p">,</span> <span class="n">dnw</span> <span class="n">inzip</span><span class="p">(</span><span class="n">nabla_w</span><span class="p">,</span> <span class="n">delta_nabla_w</span><span class="p">)]</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="p">(</span><span class="n">eta</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">mini_batch</span><span class="p">))</span><span class="o">*</span><span class="n">nw</span> 
        <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">nw</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="n">nabla_w</span><span class="p">)]</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">biases</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">-</span><span class="p">(</span><span class="n">eta</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">mini_batch</span><span class="p">))</span><span class="o">*</span><span class="n">nb</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">nb</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">biases</span><span class="p">,</span> <span class="n">nabla_b</span><span class="p">)]</span>
</pre></div>
</td></tr></table>
<p>其中大部分的工作其实是由backprop这个函数完成的，也就是我们下一章要讲的反向传播算法。它可以快速的计算损失函数的梯度，剩下的工作只是对当前mini-batch里的训练数据计算梯度值，然后再更新模型参数。完整的代码可以从上面那个git命令得到。</p>
<p>有了这些代码，通过训练数据训练出模型后再应用到测试数据上，根据作者给的参数：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">net</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">Network</span><span class="p">([</span><span class="mi">784</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span> <span class="n">net</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="n">training_data</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">test_data</span> <span class="o">=</span> <span class="n">test_data</span><span class="p">)</span>
</pre></div>
</td></tr></table>
<p>运行了一下结果如下：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">Epoch</span> <span class="mi">0</span><span class="p">:</span> <span class="mi">8335</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">8424</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">8482</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">8493</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">8551</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">5</span><span class="p">:</span> <span class="mi">8552</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">6</span><span class="p">:</span> <span class="mi">8554</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">7</span><span class="p">:</span> <span class="mi">8572</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">8</span><span class="p">:</span> <span class="mi">8595</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">9</span><span class="p">:</span> <span class="mi">8602</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">10</span><span class="p">:</span> <span class="mi">8597</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">11</span><span class="p">:</span> <span class="mi">8613</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">12</span><span class="p">:</span> <span class="mi">8611</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">13</span><span class="p">:</span> <span class="mi">8603</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">14</span><span class="p">:</span> <span class="mi">8582</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">15</span><span class="p">:</span> <span class="mi">8628</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">16</span><span class="p">:</span> <span class="mi">8613</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">17</span><span class="p">:</span> <span class="mi">8614</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">18</span><span class="p">:</span> <span class="mi">8614</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">19</span><span class="p">:</span> <span class="mi">8614</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">20</span><span class="p">:</span> <span class="mi">8611</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">21</span><span class="p">:</span> <span class="mi">8613</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">22</span><span class="p">:</span> <span class="mi">8807</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">23</span><span class="p">:</span> <span class="mi">9458</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">24</span><span class="p">:</span> <span class="mi">9486</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">25</span><span class="p">:</span> <span class="mi">9464</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">26</span><span class="p">:</span> <span class="mi">9482</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">27</span><span class="p">:</span> <span class="mi">9445</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">28</span><span class="p">:</span> <span class="mi">9487</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="n">Epoch</span> <span class="mi">29</span><span class="p">:</span> <span class="mi">9497</span> <span class="o">/</span> <span class="mi">10000</span>
</pre></div>
</td></tr></table>
<p>虽然开始时并没有作者运行时的准确率高，不过最后还是达到了95%左右的不错的准确率。仅仅是第一次测试就有这样的准确率已经很不错了，试着将隐藏层的神经元个数改为100，结果获得了提升到了96%左右，但是运行速度也慢了好多。</p>
<p>除了隐藏层的神经元个数，还有很多参数可以调节。通常来说，给神经网络调参是一件富有挑战的事，特别是当你初始参数选的很糟糕的时候。但是这门课程会让我们知道这其实并不是很重要。我们需要去培养一些直觉，一些如何去选择超参和合适的模型结构的直觉。我们将会在本书中继续讨论上述参数是怎么选择出来的。</p>
<h3 id="_13">练习</h3>
<p>问题：</p>
<p>利用代码创建一个只有两层的神经网络，即只有输入输出层，训练后进行测试得到了多少准确率？</p>
<p>答案：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">net</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">Network</span><span class="p">([</span><span class="mi">784</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span> <span class="n">net</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="n">training_data</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">test_data</span><span class="o">=</span><span class="n">test_data</span><span class="p">)</span>
</pre></div>
</td></tr></table>
<p>我测试的是准确率下降了，在84%左右。</p>
<p>之前提到我们的神经网络算法在测试集上获得了不错的准确率94%，那么这个比较的基准是什么呢？如果是胡乱猜，那就是10%的准确率。还有一种是根据图片中平均灰度值，这个有人试验过获得了22.25%的准确率，相比10%已经提高了很多了。其他还有很多可以提高准确率的想法，但是一般要提高到50%以上就要依靠机器学习算法了。SVM直接用在原来的数据上大概获得了94%的准确，也很不错，而且在最优化的参数选择下，SVM可以达到98.5%的非常高的准确率。不过神经网络也有很大的改进余地，最好的结果更是高达99.79%，而且算法的改进也并不复杂，涉及的都是这篇文章提到的概念。作者也给出了这样一句话，对于很多问题来说：</p>
<p><strong>ophisticated algorithm ≤ simple learning algorithm + good training data</strong></p>
<h2 id="_14">九. 关于深度学习</h2>
<p>虽然我们的神经网络在数字识别这个问题上获得了很不错的表现，但是它还是有一些神秘。因为无论是weights还是biases都是自动学习得到的，对于模型我们没办法给出一个合理性的解释。是否存在一些途径使我们理解神经网络究竟是使用哪些原则进行数字识别的呢，如果知道了这些原则，是否可以获得更高的准确率？</p>
<p>为了回答这些问题，我们先回到一开始神经元的解释，就是一个对多种迹象（输入）进行加权求和的过程。假设我们想要判断下面的图片中是否存在人脸：</p>
<p><img alt="" src="./images/sdxxsjwl116.png"/></p>
<p>我们可以采用类似于解决手写字体识别方法解决这个问题，将图片展开为多维向量作为神经网络的输入，然后输出就一个可以判断是否是脸的神经元。</p>
<p>不过不同的是，这次我们不用学习算法，我们人为设置权重和偏差。根据直觉我们将问题分解为多个子问题：左上是否有眼睛？右上是否有眼睛？中间是否有鼻子？等等。</p>
<p>然后如果有多个回答是“yes”，我们就认定这是一个脸，否则就不是。</p>
<p>不过这只是我们根据直觉考虑的，它存在很多问题。比如说图片角度问题就会导致脸部变形，或者眼睛识别不准等等。然而直觉告诉我们，如果可以使用神经网络解决这些子问题，那么我们也许就可以根据这些子问题的结果来解决人脸识别的问题，类似于下图中结合多个子神经网络：</p>
<p><img alt="" src="./images/sdxxsjwl117.png"/></p>
<p>不过这并不是人脸识别技术采用的方法，这里只是帮助我们建立神经网络是如何运转的直觉。</p>
<p>然后子神经网络同样可以被再次分解：</p>
<p><img alt="" src="./images/sdxxsjwl118.png"/></p>
<p>通过这样一层层的神经网络，就可以将问题分解的越来越小。神经网络通过这种方法，在前面的层上解决一些简单具体的问题，后面的层上解决更加复杂抽象的问题。这种一层层堆积，多层的结构被称为深度神经网络。</p>
<p>当然作者这里并没有真的去手动设置神经网络的各个参数，这些参数还是得靠学习算法决定。这里主要是让大家理解神经网络的层级这个概念，它一层层的结构对于这个模型意味着什么。</p>
<p>自2006年后，随着一系列技术的发展，使得深度学习成为可能。在很多问题上，深度学习想较于浅层神经网络获得了很大的效果提升。原因当然是，深度网络可以建立一个更加复杂的层级结构去解决复杂的问题。类似于我们在传统编程语言中的模块化设计和抽象设计去实现具有更加复杂功能的程序。</p>
<p>之后的文章可能不会像这篇一样了，翻译原文太长了，还是尽量精简提炼一下吧。。。</p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
            
            
            <hr/>
            <aside>
            <nav>
            <ul class="articles-timeline">
                <li class="previous-article">« <a href="/spark-mlxia-shi-xian-de-duo-fen-lei-adaboost-naivebayessuan-fa.html" title="Previous: Spark ML下实现的多分类AdaBoost + NaiveBayes算法 - 及其在文本分类上的应用">Spark ML下实现的多分类AdaBoost + NaiveBayes算法 <small>及其在文本分类上的应用</small></a></li>
                <li class="next-article"><a href="/shen-du-xue-xi-yu-shen-jing-wang-luo-bi-ji-2.html" title="Next: 《深度学习与神经网络》笔记2 - 反向传播算法">《深度学习与神经网络》笔记2 <small>反向传播算法</small></a> »</li>
            </ul>
            </nav>
            </aside>
        </div>
        <section>
        <div class="span2" style="float:right;font-size:0.9em;">
            <h4>Published</h4>
            <time pubdate="pubdate" datetime="2017-08-23T20:00:00+08:00">2017  - 08  - 23</time>
            <h4>Category</h4>
            <a class="category-link" href="/categories.html#shen-du-xue-xi-ref">深度学习
                <span>(8)</span>
</a>
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="/tags.html#shen-du-xue-xi-ref">深度学习
                    <span>9</span>
</a></li>
                <li><a href="/tags.html#shen-du-xue-xi-yu-shen-jing-wang-luo-bi-ji-ref">《深度学习与神经网络》笔记
                    <span>6</span>
</a></li>
                <li><a href="/tags.html#suan-fa-ref">算法
                    <span>12</span>
</a></li>
            </ul>
                <div class="widget blogroll">
                        <h4>Blogroll</h4>
                        <ul>
                            <li><a href="http://blogwall.us/">Blogwall</a></li>
                            <li><a href="http://www.matrix67.com/">Matrix67</a></li>
                            <li><a href="http://blog.echen.me/">EdwinChen</a></li>
                        </ul>
                </div><!-- /.blogroll -->
<h4>Contact</h4>
    <a href="mailto:shangzhi.huang@gmail.com" title="My email Address" class="sidebar-social-links" target="_blank">
    <i class="fa fa-envelope sidebar-social-links"></i></a>
    <a href="https://github.com/ShangzhiH" title="My github Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-github sidebar-social-links"></i></a>
    <a href="feeds/all.rss.xml" title="Subscribe in a reader" class="sidebar-social-links" target="_blank">
    <i class="fa fa-rss sidebar-social-links"></i></a>
        </div>
        </section>
</div>
</article>
                </div>
                <div class="span1"></div>
            </div>
        </div>
        <div id="push"></div>
    </div>
<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a></li>
    </ul>
</div>
</footer>            <script src="http://code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

    
    </body>
    <!-- Theme: Elegant built for Pelican
    License : http://oncrashreboot.com/pelican-elegant -->
</html>