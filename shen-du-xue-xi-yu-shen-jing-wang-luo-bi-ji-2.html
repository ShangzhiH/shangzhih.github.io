<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8"> 
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="Shangzhi HUANG" />
        <meta name="copyright" content="Shangzhi HUANG" />

        <meta property="og:type" content="article" />
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="算法, 深度学习, 《深度学习与神经网络》笔记, 深度学习, " />

<meta property="og:title" content="《深度学习与神经网络》笔记2  - 反向传播算法 "/>
<meta property="og:url" content="/shen-du-xue-xi-yu-shen-jing-wang-luo-bi-ji-2.html" />
<meta property="og:description" content="上一章中我们遗留了一个问题，就是在神经网络的学习过程中，在更新参数的时候，如何去计算损失函数关于参数的梯度。这一章，我们将会学到一种快速的计算梯度的算法：反向传播算法。 这一章相较于后面的章节涉及到的数学知识比较多，如果阅读上有点吃力的话也可以完全跳过这一章，把反向传播当成一个计算梯度的黑盒即可，但是学习这些数学知识可以帮助我们更深入的理解神经网络。 反向传播算法的核心目的是对于神经网络中的任何weight或bias计算损失函数\(C\)关于它们的偏导数\(\frac{\partial C}{\partial w}\). 这个式子能够帮助我们知道当我们改变\(w\)或\(b\)的时候，损失函数\(C\)是怎么变化的。虽然计算这个式子可能有一点复杂，但是它提供了一种自然的，直观的解释，所以说反向传播算法并不仅仅是一种快速学习算法，它提供给我们具体的见解，帮助我们理解改变神经网络的参数是如何改变神经网络行为的。所以说反向传播算法是很值得我们去深入学习的。 当然跳过这章也没问题，把反向传播当作求梯度的黑盒也并不影响阅读作者后续的章节。虽然后面会有一些涉及到本章知识的地方，不过跳过这些依然不会影响我们理解文章的主要内容。 一. 一种基于矩阵运算快速计算神经网络输出的方法 在介绍反向传播之前，先介绍怎么利用矩阵运算快速的计算神经网络输出。其实在上一章对这一块也提到过，不过不够详细。这里再介绍一下，帮助大家逐渐适应基于矩阵运算的表示方式。 我们先引入一个能够明确表示连接神经网络中某两层之间的某两个神经元的权重的符号：\(w^l_{jk …" />
<meta property="og:site_name" content="Shangzhi HUANG&#39;s Blog" />
<meta property="og:article:author" content="Shangzhi HUANG" />
<meta property="og:article:published_time" content="2017-09-01T20:00:00+08:00" />
<meta name="twitter:title" content="《深度学习与神经网络》笔记2  - 反向传播算法 ">
<meta name="twitter:description" content="上一章中我们遗留了一个问题，就是在神经网络的学习过程中，在更新参数的时候，如何去计算损失函数关于参数的梯度。这一章，我们将会学到一种快速的计算梯度的算法：反向传播算法。 这一章相较于后面的章节涉及到的数学知识比较多，如果阅读上有点吃力的话也可以完全跳过这一章，把反向传播当成一个计算梯度的黑盒即可，但是学习这些数学知识可以帮助我们更深入的理解神经网络。 反向传播算法的核心目的是对于神经网络中的任何weight或bias计算损失函数\(C\)关于它们的偏导数\(\frac{\partial C}{\partial w}\). 这个式子能够帮助我们知道当我们改变\(w\)或\(b\)的时候，损失函数\(C\)是怎么变化的。虽然计算这个式子可能有一点复杂，但是它提供了一种自然的，直观的解释，所以说反向传播算法并不仅仅是一种快速学习算法，它提供给我们具体的见解，帮助我们理解改变神经网络的参数是如何改变神经网络行为的。所以说反向传播算法是很值得我们去深入学习的。 当然跳过这章也没问题，把反向传播当作求梯度的黑盒也并不影响阅读作者后续的章节。虽然后面会有一些涉及到本章知识的地方，不过跳过这些依然不会影响我们理解文章的主要内容。 一. 一种基于矩阵运算快速计算神经网络输出的方法 在介绍反向传播之前，先介绍怎么利用矩阵运算快速的计算神经网络输出。其实在上一章对这一块也提到过，不过不够详细。这里再介绍一下，帮助大家逐渐适应基于矩阵运算的表示方式。 我们先引入一个能够明确表示连接神经网络中某两层之间的某两个神经元的权重的符号：\(w^l_{jk …">

        <title>《深度学习与神经网络》笔记2  - 反向传播算法  · Shangzhi HUANG&#39;s Blog
</title>
        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet">
        <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.1/css/font-awesome.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="/theme/css/pygments.css" media="screen">
        <link rel="stylesheet" type="text/css" href="/theme/tipuesearch/tipuesearch.css" media="screen">
        <link rel="stylesheet" type="text/css" href="/theme/css/elegant.css" media="screen">
        <link rel="stylesheet" type="text/css" href="/theme/css/custom.css" media="screen">
        <link rel="shortcut icon" href="/theme/images/favicon.ico" type="image/x-icon" type="image/png" />
        <link rel="icon" href="/theme/images/apple-touch-icon-152x152.png" type="image/png" />
        <link rel="apple-touch-icon" href="/theme/images/apple-touch-icon.png"  type="image/png" />
        <link rel="apple-touch-icon" sizes="57x57" href="/theme/images/apple-touch-icon-57x57.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="72x72" href="/theme/images/apple-touch-icon-72x72.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="76x76" href="/theme/images/apple-touch-icon-76x76.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="114x114" href="/theme/images/apple-touch-icon-114x114.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="120x120" href="/theme/images/apple-touch-icon-120x120.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="144x144" href="/theme/images/apple-touch-icon-144x144.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="152x152" href="/theme/images/apple-touch-icon-152x152.png" type="image/png" />
        <link href="/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="Shangzhi HUANG&#39;s Blog - Full RSS Feed" />
    </head>
    <body>
        <div id="content-sans-footer">
        <div class="navbar navbar-static-top">
            <div class="navbar-inner">
                <div class="container-fluid">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" href="/"><span class=site-name>Shangzhi HUANG's Blog</span></a>
                    <div class="nav-collapse collapse">
                        <ul class="nav pull-right top-menu">
                            <li ><a href="/">Home</a></li>
                            <li ><a href="/categories.html">Categories</a></li>
                            <li ><a href="/tags.html">Tags</a></li>
                            <li ><a href="/archives.html">Archives</a></li>
                            <li><form class="navbar-search" action="/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span1"></div>
                <div class="span10">
<article>
<div class="row-fluid">
    <header class="page-header span10 offset2">
    <h1><a href="/shen-du-xue-xi-yu-shen-jing-wang-luo-bi-ji-2.html"> 《深度学习与神经网络》笔记2  <small> 反向传播算法 </small>  </a></h1>
    </header>
</div>

<div class="row-fluid">
    <div class="span2 table-of-content">
        <nav>
        <h4>Contents</h4>
        <div class="toc">
<ul>
<li><a href="#_1">一. 一种基于矩阵运算快速计算神经网络输出的方法</a></li>
<li><a href="#_2">二. 关于损失函数的两个假设</a></li>
<li><a href="#hadamard-sodot-t">三. Hadamard积 - \(s\odot t\)</a></li>
<li><a href="#_3">四. 反向传播算法背后的四个基本方程</a><ul>
<li><a href="#errordelta-l">方程一：输出层的error\(\delta ^L\)</a></li>
<li><a href="#errorerror">方程二：用当前层error表示下一层error</a></li>
<li><a href="#errorcbias">方程三：error等价于损失函数\(C\)对bias的变化率</a></li>
<li><a href="#cweights">方程四：损失函数\(C\)对weights的变化率</a></li>
</ul>
</li>
<li><a href="#_4">五. 四个方程的证明(选学)</a><ul>
<li><a href="#_5">练习</a></li>
</ul>
</li>
<li><a href="#_6">六. 反向传播算法</a><ul>
<li><a href="#_7">练习</a></li>
</ul>
</li>
<li><a href="#_8">七. 反向传播算法的代码实现</a></li>
<li><a href="#_9">八. 反向传播为什么被认为是快速的算法？</a></li>
<li><a href="#_10">九. 反向传播概貌</a></li>
</ul>
</div>
        </nav>
    </div>
    <div class="span8 article-content">

            
            
<p>上一章中我们遗留了一个问题，就是在神经网络的学习过程中，在更新参数的时候，如何去计算损失函数关于参数的梯度。这一章，我们将会学到一种快速的计算梯度的算法：反向传播算法。</p>
<p>这一章相较于后面的章节涉及到的数学知识比较多，如果阅读上有点吃力的话也可以完全跳过这一章，把反向传播当成一个计算梯度的黑盒即可，但是学习这些数学知识可以帮助我们更深入的理解神经网络。</p>
<p>反向传播算法的核心目的是对于神经网络中的任何weight或bias计算损失函数<span class="math">\(C\)</span>关于它们的偏导数<span class="math">\(\frac{\partial C}{\partial w}\)</span>. 这个式子能够帮助我们知道当我们改变<span class="math">\(w\)</span>或<span class="math">\(b\)</span>的时候，损失函数<span class="math">\(C\)</span>是怎么变化的。虽然计算这个式子可能有一点复杂，但是它提供了一种自然的，直观的解释，所以说反向传播算法并不仅仅是一种快速学习算法，它提供给我们具体的见解，帮助我们理解改变神经网络的参数是如何改变神经网络行为的。所以说反向传播算法是很值得我们去深入学习的。</p>
<p>当然跳过这章也没问题，把反向传播当作求梯度的黑盒也并不影响阅读作者后续的章节。虽然后面会有一些涉及到本章知识的地方，不过跳过这些依然不会影响我们理解文章的主要内容。</p>
<h2 id="_1">一. 一种基于矩阵运算快速计算神经网络输出的方法</h2>
<p>在介绍反向传播之前，先介绍怎么利用矩阵运算快速的计算神经网络输出。其实在上一章对这一块也提到过，不过不够详细。这里再介绍一下，帮助大家逐渐适应基于矩阵运算的表示方式。</p>
<p>我们先引入一个能够明确表示连接神经网络中某两层之间的某两个神经元的权重的符号：<span class="math">\(w^l_{jk}\)</span>，它表示第<span class="math">\(l-1\)</span>层的第<span class="math">\(k\)</span>个神经元和第<span class="math">\(l\)</span>层的第<span class="math">\(j\)</span>个神经元连接的权重。例如下图中的<span class="math">\(w^3_{24}\)</span>表示第二层的第4个神经元到第三层的第2个神经元的权重：</p>
<p><img alt="" src="./images/sdxxsjwl21.png"/>
这个符号初看起来可能有点复杂冗长而且需要一点功夫去适应这样的定义。而且大多数人应该有跟我一样的疑惑就是为什么不用j表示输入，k表示输出，而是这样反其道而行之。在下文中作者将解释这样定义的原因。</p>
<p>同样的我们可以用类似的符号定义神经元的bias和受到激活后的输出。我们用<span class="math">\(b^l_j\)</span>表示第<span class="math">\(l\)</span>层第<span class="math">\(j\)</span>个神经元的bias，用<span class="math">\(a^l_j\)</span>表示第<span class="math">\(l\)</span>层第<span class="math">\(j\)</span>个神经元的输出。类似下图：</p>
<p><img alt="" src="./images/sdxxsjwl22.png"/></p>
<p>有了这些概念，我们可以把<span class="math">\(a^l_j\)</span>也就是第<span class="math">\(l\)</span>层第<span class="math">\(j\)</span>个神经元的输出同上一层神经元的输出联系起来。</p>
<div class="math">$$a^l_j = \sigma (\sum_k w^l_{jk}a^{l-1}_k + b^l_j) \quad (23)$$</div>
<p>这个式子中的求和部分就是对上一层的神经元输出进行加权求和的过程。</p>
<p>为了用矩阵的形式重写这个式子，我们定义一个权重矩阵<span class="math">\(w^l\)</span>表示与第<span class="math">\(l\)</span>层所有神经元链接的权重，这个矩阵的第<span class="math">\(j\)</span>行，第<span class="math">\(k\)</span>列的值<span class="math">\(w^l_{jk}\)</span>表示第<span class="math">\(l-1\)</span>层第<span class="math">\(k\)</span>个神经元与第<span class="math">\(l\)</span>层第<span class="math">\(j\)</span>个神经元链接的权重。同样的定义一个bias向量<span class="math">\(b^l\)</span>表示第<span class="math">\(l\)</span>层神经元的bias，然后<span class="math">\(a^l\)</span>表示第<span class="math">\(l\)</span>层神经元的输出。</p>
<p>借助于函数向量化的思想，就是将一个函数作用于一个向量上等价于将一个函数分别作用于该向量上每一个分量。例如对于函数<span class="math">\(f(x)=x^2\)</span>,有：</p>
<div class="math">$$f(\begin{bmatrix} 2\\ 3 \end{bmatrix}) = \begin{bmatrix} f(2)\\f(3)\end{bmatrix}=\begin{bmatrix}4\\9\end{bmatrix} \quad (24)$$</div>
<p>有了这些概念就可以将公式(23)改写为：</p>
<div class="math">$$a^l = \sigma (w^l a^{l-1} + b^l) \quad (25)$$</div>
<p>去掉了那些表示神经元的序号<span class="math">\(j\)</span>和<span class="math">\(k\)</span>，这个式子帮助我们更宏观的理解上一层神经元的输出是怎么影响下一次神经元的。我们将权重矩阵乘以上一层神经元输出，再加上这一层神经元自身的bias，再经过<span class="math">\(\sigma\)</span>函数得到的就是这一层神经元的输出。</p>
<p>这也是作者定义<span class="math">\(w^l_{jk}\)</span>时用<span class="math">\(k\)</span>表示<span class="math">\(l-1\)</span>层的神经元序列而不是用<span class="math">\(j\)</span>表示的原因。试想一下，当我们需要计算第<span class="math">\(l\)</span>层第一个神经元输出的时候，需要将矩阵<span class="math">\(w^l\)</span>的第一行所有值<span class="math">\(w^l_{1k}\)</span>表示的向量和向量<span class="math">\(a^{l-1}\)</span>相乘，也就是加权求和，所以说这样定义更符合我们矩阵运算的规则，否则的话在进行计算的时候还需要将权重矩阵<span class="math">\(w^l\)</span>转置带来不必要的麻烦。</p>
<p>相较于纠结神经元间的联系，用矩阵表示的话更容易理解和感受层级间的联系。而且矩阵表示还有个好处就是在实际工程中，有很多快速矩阵运算的实现。</p>
<p>在计算公式(25)的时候，我们可以定义一个<span class="math">\(l\)</span>层的加权输入的概念：<span class="math">\(z^l = w^l a^{l-1} + b^l\)</span>，就是在经过<span class="math">\(\sigma\)</span>函数输出之前的部分。公式(25)于是可以表示成<span class="math">\(a^l = \sigma (z^l)\)</span>。<span class="math">\(z^l\)</span>当然也是一个向量，其中每个分量<span class="math">\(z^l_j\)</span>表示第<span class="math">\(l\)</span>层第<span class="math">\(j\)</span>个神经元的加权输入。</p>
<h2 id="_2">二. 关于损失函数的两个假设</h2>
<p>反向传播算法是为了计算损失函数的偏导数<span class="math">\(\frac{\partial C}{\partial w}\)</span>和<span class="math">\(\frac{\partial C}{\partial b}\)</span>，为了使算法可行，我们需要对损失函数的形式作两个假设。在介绍这些假设之前，我们先来看一个最常见的二次损失函数：</p>
<div class="math">$$C=\frac{1}{2n}\sum_x ||y(x)-a^L (x)||^2 \quad (26)$$</div>
<p>其中<span class="math">\(n\)</span>是训练样本总数，对所有训练样本损失求平均，<span class="math">\(y(x)\)</span>是输入为<span class="math">\(x\)</span>时对应的真实的输出，而<span class="math">\(L\)</span>表示神经网络的层数，也就是说<span class="math">\(a^L (x)\)</span>表示的是输入为<span class="math">\(x\)</span>时，神经网络最后一层输出层的输出，也就是神经网络的输出。</p>
<p>第一个假设是所有训练样本总的损失函数可以被表示成单个样本损失函数和的平均值，即：<span class="math">\(C=\frac{1}{n}\sum_x C_x\)</span>. 我们很容易可以验证这个假设对于二次损失函数成立，<span class="math">\(C_x = \frac{1}{2}||y-a^L||^2\)</span>。这个假设其实大部分时候都是成立，除了对于少数比较另类的损失函数，不过本文并不涉及。</p>
<p>我们需要这个假设的原因是因为方向传播算法实际是对于单个样本计算偏导数<span class="math">\(\frac{\partial C_x}{\partial w}\)</span>和<span class="math">\(\frac{\partial C_x}{\partial b}\)</span>,随后再通过对这些单样本的偏导数求平均作为<span class="math">\(\frac{\partial C}{\partial w}\)</span>和<span class="math">\(\frac{\partial C}{\partial b}\)</span>。事实上，在对<span class="math">\(w\)</span>和<span class="math">\(b\)</span>求偏导的时候，我们将输入<span class="math">\(x\)</span>当作是固定值，所以方便起见，暂时将<span class="math">\(C_x\)</span>写作<span class="math">\(C\)</span>,后面再写回来。</p>
<p>第二个假设是损失函数可以表示成神经网络输出的函数，即<span class="math">\(C = C(a^L)\)</span></p>
<p><img alt="" src="./images/sdxxsjwl23.png"/></p>
<p>例如，二次损失函数就满足这样的假设，因为对于一个训练样本<span class="math">\(x\)</span>来说，有：</p>
<div class="math">$$C=\frac{1}{2}||y-a^L||^2=\frac{1}{2}\sum_j (y_j - a^L_j)^2 \quad (27)$$</div>
<p>这样就表示成了输出的函数，因为对于一个输入<span class="math">\(x\)</span>来说，它实际正确的输出<span class="math">\(y\)</span>是个固定值，并不是我们可以修改的变量。我们可以改变的只能是通过改变weights和biases来改变神经网络的输出<span class="math">\(a^L\)</span>从而影响到损失函数的值。</p>
<h2 id="hadamard-sodot-t">三. Hadamard积 - <span class="math">\(s\odot t\)</span></h2>
<p>反向传播算法基于一些常见的线性代数操作：向量的相加，向量与矩阵的积等等。其中有一种操作不是很常见，这里简单介绍一下。假设<span class="math">\(s\)</span>和<span class="math">\(t\)</span>是两个相同维度的向量，我们使用<span class="math">\(s\odot t\)</span>定义两个向量中对应分量相乘的操作，即<span class="math">\((s \odot t)_j = s_j t_j\)</span>,例如：</p>
<div class="math">$$\begin{bmatrix} 1\\ 2 \end{bmatrix} \odot \begin{bmatrix} 3\\ 4 \end{bmatrix} = \begin{bmatrix} 1*3 \\ 2*4\end{bmatrix}=\begin{bmatrix}3\\8 \end{bmatrix} \quad (28)$$</div>
<p>这样的乘法操作被称为Hadamard积或Schur积。</p>
<h2 id="_3">四. 反向传播算法背后的四个基本方程</h2>
<p>反向传播算法是关于理解改变weights和biases是如何改变损失函数C，也就是计算<span class="math">\(\frac{\partial C}{\partial w^l_{jk}}\)</span>和<span class="math">\(\frac{\partial C}{\partial b^l_j}\)</span>。在介绍如何计算这些偏导数之前，先引入一个中间变量，<span class="math">\(\delta^l_j\)</span>，称其为第<span class="math">\(l\)</span>层第<span class="math">\(j\)</span>个神经元的误差error，反向传播算法会先计算这个中间变量，随后再将其与需要的偏导数关联起来。</p>
<p>为了明白这个error的定义，想象在我们的神经网络中有一个小恶魔：</p>
<p><img alt="" src="./images/sdxxsjwl24.png"/></p>
<p>这个小恶魔位于第<span class="math">\(l\)</span>层第<span class="math">\(j\)</span>个神经元处，它会在该神经元接收到输入的时候使坏，在上一层的加权输入和传到这个神经元的时候添加一个改变量<span class="math">\(\Delta z^l_j\)</span>，导致该神经元的输出就不再是<span class="math">\(\sigma (z^l_j)\)</span>而变成了<span class="math">\(\sigma (z^l_j + \Delta z^l_j)\)</span>。这个改变就会一直传到下去直到最后一个输出层，使得总的损失函数改变了<span class="math">\(\frac{\partial C}{\partial z^l_j}\Delta z^l_j\)</span>。</p>
<p>现在假设这个恶魔是个好恶魔，它会通过找到合适的<span class="math">\(\Delta z^l_j\)</span>来帮我们减小损失函数的值。假设<span class="math">\(\frac{\partial C}{\partial z^l_j}\)</span>是一个绝对值大的数(可以是正数或者负数)，那我们可以取一个和其正负相反的一个数<span class="math">\(\Delta z^l_j\)</span>来减小损失函数。但是如果<span class="math">\(\frac{\partial C}{\partial z^l_j}\)</span>是一个接近0的数，这个恶魔通过影响<span class="math">\(z^l_j\)</span>来减小损失函数的方式就显得力不从心了。此时，这个恶魔就会说，这个神经元已经接近最优状态了（当然这是在<span class="math">\(\Delta z^l_j\)</span>是相对小的值的情况下的，我们会约束这个恶魔的能力，使其只能进行这些比较小的干扰）。这就有点类似于说损失函数在这个神经元上已经达到极值，没有继续优化的空间了。</p>
<p>这就给我们一种直觉说<span class="math">\(\frac{\partial C}{\partial z^l_j}\)</span>可以作为该神经元error的一种评价方式。基于此，我们定义第<span class="math">\(l\)</span>层第<span class="math">\(j\)</span>个神经元的error为：</p>
<div class="math">$$\delta^l_j = \frac{\partial C}{\partial z^l_j}\quad (29)$$</div>
<p>反向传播算法将会对每一层<span class="math">\(l\)</span>计算<span class="math">\(\delta^l\)</span>然后再得到对应的<span class="math">\(\frac{\partial C}{\partial w^l_{jk}}\)</span>和<span class="math">\(\frac{\partial C}{\partial b^l_j}\)</span>。</p>
<p>也许我们会有疑问为什么这个恶魔影响的是输入<span class="math">\(z^l_j\)</span>而不是直接去影响输出<span class="math">\(a^l_j\)</span>，那样我们就可以用<span class="math">\(\frac{\partial C}{\partial a^l_j}\)</span>作为我们在神经元上error的衡量。实际上这样做并不会对结果产生影响，只是会使得反向传播算法的计算公式更复杂一点而已，所以我们继续使用<span class="math">\(\delta^l_j = \frac{\partial C}{\partial z^l_j}\)</span>作为error的衡量。</p>
<p>接下来就要介绍反向传播算法基于的四个方程了。作者在这强调，这些方程是有难度的，一开始不理解也不要灰心。在这章中，我们会多次学习它们，作者还给出了这些方程的简单证明和伪代码实现，并且还一步步将伪代码实现成了python代码。通过本章的学习，不光是知道这些公式方程，作者还将会使我们对反向传播方程有直觉上的理解，还有就是人们是怎么发现这些方程的。在这期间，我们会不断的提及这四个方程，使我们最终将会对它有更深入的理解。</p>
<h3 id="errordelta-l">方程一：输出层的error<span class="math">\(\delta ^L\)</span></h3>
<div class="math">$$\delta^L_j = \frac{\partial C}{\partial a^L_j}\sigma '(z^L_j) \quad (BP1)$$</div>
<p>根据定义我们可以验证<span class="math">\(\delta^L_j = \frac{\partial C}{\partial z^L_j} = \frac{\partial C}{\partial a^L_j}\frac{\partial a^L_j}{\partial z^L_j} = \frac{\partial C}{\partial a^L_j}\sigma '(z^L_j)\)</span></p>
<p>注意到这个式子的每个部分都不难计算的到，<span class="math">\(z^L_j\)</span>和<span class="math">\(\sigma '(z^L_j)\)</span>在计算神经网络输出的时候可以得到，左边的部分在确定了损失函数的形式之后也可以计算得到。</p>
<p>公式(BP1)是针对输出层上某一个神经元而言的，为了方便反向传播计算，我们将其改写为矩阵形式：</p>
<div class="math">$$\delta^L = \bigtriangledown_aC \odot \sigma '(z^L) \quad (BP1a)$$</div>
<p>对于这里的二次损失函数，有<span class="math">\(\bigtriangledown_a C = \bigtriangledown_a (\frac{1}{2}\sum_j (y_j - a^L_j)^2) = a^L - y\)</span>, 注意这里求导的过程只是针对当前分量<span class="math">\(j\)</span>求导，其余的分量就为0.于是有：</p>
<div class="math">$$\delta^L = (a^L - y) \odot \sigma'(z^L) \quad (30)$$</div>
<h3 id="errorerror">方程二：用当前层error表示下一层error</h3>
<div class="math">$$\delta^l = ((w^{l+1})^T\delta^{l+1}) \odot \sigma'(z^l) \quad (BP2)$$</div>
<p>这个方程虽然看上去比较复杂，但是每个部分都有很明确的解释。假设我们知道<span class="math">\(l+1\)</span>层的error：<span class="math">\(\delta^{l+1}\)</span>，当同这一层的权重矩阵相乘的时候就类似于将这个error传到上一层，最后再利用Hadamard积得到<span class="math">\(l\)</span>层的error。详细的推导证明在下一小节中。</p>
<p>有了公式(BP1)和公式(BP2)我们就可以通过先计算输出层的error进而计算每一层的error。</p>
<h3 id="errorcbias">方程三：error等价于损失函数<span class="math">\(C\)</span>对bias的变化率</h3>
<div class="math">$$\frac{\partial C}{\partial b^l_j} = \delta^l_j \quad (BP3)$$</div>
<p>这说明error <span class="math">\(\delta^l_j\)</span>等价于<span class="math">\(\frac{\partial C}{\partial b^l_j}\)</span>。于是可以很容易将其写成：</p>
<div class="math">$$\frac{\partial C}{\partial b} = \delta \quad (31)$$</div>
<h3 id="cweights">方程四：损失函数<span class="math">\(C\)</span>对weights的变化率</h3>
<div class="math">$$\frac{\partial C}{\partial w^l_{jk}} = a^{l-1}_k\delta^l_j \quad (BP4)$$</div>
<p>这个方程说明，当我们要计算某两个神经元链接的权重对损失函数影响的时候，可以先计算上一层的<span class="math">\(a^{l-1}_k\)</span>和下一层的<span class="math">\(\delta^l_j\)</span>。而这两个值我们根据先前的知识已经知道怎么计算了。这个方程也可以被写为：</p>
<div class="math">$$\frac{\partial C}{\partial w} = a_{in}\delta_{out} \quad (32)$$</div>
<p>更直观的如下图所示：</p>
<p><img alt="" src="./images/sdxxsjwl25.png"/></p>
<p>从公式(32)中可以看出来，当<span class="math">\(a_{in}\)</span>很小<span class="math">\(a_{in}\approx 0\)</span>的时候，<span class="math">\(\partial C/\partial w\)</span>也会很小，那样这个权重的学习就会很慢，意味着在梯度下降的学习过程中，这个权重不会发生大的变化。换句话说就是，输出小的神经元的权重学习也慢。</p>
<p>介绍完了这四个方程，我们再来聊聊一些关于这四个方程的理解。对于输出层，考虑公式(BP1)中的<span class="math">\(\sigma'(z^L_j)\)</span>，我们在第一章学习过<span class="math">\(\sigma\)</span>函数的图像，知道它在<span class="math">\(\sigma (z^L_j)\)</span>接近0或1的时候是趋于平的，也就是导数是趋于0的。所以我们就能得出结论，如果对于输出层的神经元，如果其输出非常大（<span class="math">\(\approx 1\)</span>）或非常小（<span class="math">\(\approx 0\)</span>），在这种情况下，其参数的更新是非常缓慢的。我们称这种状态的输出神经元为saturated的状态，这种状态下，参数停止更新（或更新很慢）。</p>
<p>根据公式（BP2）我们对其他层可以得出同样的结论，对任一处于saturated状态的神经元来说，其<span class="math">\(\delta^l_j\)</span>趋向于很小的值，然后就会导致它的参数的学习会很慢。（当然要是<span class="math">\(w^{l+1}\delta^{l+1}\)</span>足够大，即使乘上一个很小的数也能保证积足够大的话就不是这种情形了，不过作者这里说明的只是普遍的情况）</p>
<p>总之，就是一个神经元在低激活或者高激活状态，或者说在saturated状态时，它的参数的更新就会很慢。</p>
<p>上面的一些理解并不难从观察方程得到，但是它仍然能够帮助我们更进一步在脑海中构建神经网络模型。而且我们随后会发现，证明上述方程不需要用到任何<span class="math">\(\sigma\)</span>函数的性质，所以我们可以将激活函数换成任何函数。甚至我们可以根据学习的需要设计自己的激活函数。例如，我们使用一个函数<span class="math">\(f\)</span>，有<span class="math">\(f'&gt;0\)</span>恒成立，并且不会接近于0，这样就可以使神经元避免saturated的状态，就不会减慢参数的学习。在本书的后续章节，我们的确会看到很多使用自己定义的激活函数的例子，现在先让我们牢记(BP1)-(BP4)这四个方程，只有这样到时候才能明白为什么要那样修改激活函数，这样修改会造成什么样的影响。</p>
<p><img alt="" src="./images/sdxxsjwl26.png"/></p>
<h2 id="_4">五. 四个方程的证明(选学)</h2>
<p>现在要开始上述四个方程的证明了，这些证明主要用到了多元函数微分的链式法则，如果对这块很熟悉的话，完全可以自己自行证明。</p>
<p>先来公式(BP1)的证明，这个其实在我上面介绍的时候已经证明过了，这里在介绍一下作者是怎么证明的。</p>
<p>公式BP1:</p>
<div class="math">$$\delta^L_j = \frac{\partial C}{\partial z^L_j} \quad (36)$$</div>
<p>根据链式法则有<span class="math">\(\delta^L_j = \sum_k \frac{\partial C}{\partial a^L_k}\frac{\partial a^L_k}{\partial z^L_j} \quad (37)\)</span>，但是我们知道对于第<span class="math">\(k\)</span>个神经元的输出<span class="math">\(a^L_k\)</span>只决定于第<span class="math">\(k\)</span>个神经元的输入<span class="math">\(a^L_k\)</span>，所以对于<span class="math">\(k \neq j\)</span>的情况，导数为0，所以可以去掉求和符号（其他项都为0）最后有：</p>
<div class="math">$$\delta^L_j = \frac{\partial C}{\partial a^L_j}\frac{\partial a^L_j}{\partial z^L_j} \quad (38)$$</div>
<p>由于<span class="math">\(a^L_j = \sigma (z^L_j)\)</span>，所以上式又可以被写为：</p>
<div class="math">$$\delta^L_j = \frac{\partial C}{\partial a^L_j}\sigma '(z^L_j) \quad (39)$$</div>
<p>公式BP1就得到了证明。</p>
<p>现在证明BP2.根据链式法则可以得到：</p>
<div class="math">$$\delta^l_j = \frac{\partial C}{\partial z^l_j} \quad (40)$$</div>
<div class="math">$$\delta^l_j = \sum_k \frac{\partial C}{\partial z^{l+1}_k} \frac{\partial z^{l+1}_k}{\partial z^l_j} \quad (41)$$</div>
<div class="math">$$\delta^l_j = \sum_k \frac{\partial z^{l+1}_k}{\partial z^l_j} \delta^{l+1}_k \quad (42)$$</div>
<p>又根据神经网络模型知道：</p>
<div class="math">$$z^{l+1}_k = \sum_j w^{l+1}_{kj}a^l_j+b^{l+1}_k = \sum_j w^{l+1}_{kj} \sigma(z^l_j) + b^{l+1}_k \quad (43)$$</div>
<p>然后将其对<span class="math">\(z^l_j\)</span>求导得到：</p>
<div class="math">$$\frac{\partial z^{l+1}_k}{\partial z^l_j} = w^{l+1}_{kj}\sigma '(z^l_j) \quad(44)$$</div>
<p>将其带入公式(42)得到：</p>
<div class="math">$$\delta^l_j = \sum_k w^{l+1}_{kj}\delta ^{l+1}_k\sigma '(z^l_j) \quad (45)$$</div>
<p>这样就完成了BP2的证明。</p>
<p>BP3和BP4的证明留做练习题。</p>
<h3 id="_5">练习</h3>
<p>问题：</p>
<p>证明方程BP3和BP4 </p>
<p>答案：</p>
<p>BP3的证明：</p>
<p>根据链式法则展开为<span class="math">\(\frac{\partial C}{\partial b^l_j} = \sum_k \frac{\partial C}{\partial z^l_k} \frac{\partial z^l_k}{\partial b^l_j} = \sum_k \delta^l_k \frac{\partial (\sum_j w^l_{kj}a^{l-1}_j + b^l_k)}{\partial b^l_j} = \delta^l_j * 1 = \delta^l_j\)</span></p>
<p>因为只有在<span class="math">\(k = j\)</span>的时候右边部分才为1，其余均为0，方程BP3就得到了证明。</p>
<p>BP4的证明：</p>
<p>跟BP3几乎一模一样，为了避免误解，这里的下标稍微改一下，<span class="math">\(\frac{\partial C}{\partial w^l_{jk}} = \sum_a \frac{\partial C}{\partial z^l_a} \frac{\partial z^l_a}{\partial w^l_{jk}} = \sum_a \delta^l_a \frac{\partial (\sum_b w^l_{ab}a^{l-1}_b + b^l_a)}{\partial w^l_{jk}}\)</span></p>
<p>很显然，<span class="math">\(\frac{\partial b^l_a}{w^l_{jk}}=0\)</span>,然后另一部分只有在<span class="math">\(a=j,b=k\)</span>时才不为0，此时就可以去掉求和符号得到：</p>
<div class="math">$$\frac{\partial C}{\partial w^l_{jk}} = a^{l-1}_k \delta^l_j$$</div>
<p>方程BP4证明完毕。</p>
<h2 id="_6">六. 反向传播算法</h2>
<p>有了这些方程，我们再看看反向传播算法是如何进行梯度计算的。</p>
<ol>
<li>
<p>设置输入层的输出<span class="math">\(a^1\)</span>为原始输入<span class="math">\(x\)</span></p>
</li>
<li>
<p>前向依次计算<span class="math">\(l=2,3,...,L\)</span>层的加权输入和输出:<span class="math">\(z^l = w^la^{l-1}+b^l\)</span>和<span class="math">\(a^l = \sigma (z^l)\)</span></p>
</li>
<li>
<p>输出层的error <span class="math">\(\delta^L\)</span>: <span class="math">\(\delta^L = \bigtriangledown_a C \odot \sigma '(z^L)\)</span></p>
</li>
<li>
<p>反向传播依次计算<span class="math">\(l=L-1, L-2, ..., 2\)</span>层的error：<span class="math">\(\delta^l = ((w^{l+1})^T\delta^{l+1}) \odot \sigma '(z^l)\)</span></p>
</li>
<li>
<p>根据上面的结果计算各个梯度：<span class="math">\(\frac{\partial C}{\partial w^l_{jk}} = a^{l-1}_k\delta^l_j\)</span>和<span class="math">\(\frac{\partial C}{\partial b^l_j} = \delta^l_j\)</span></p>
</li>
</ol>
<p>从算法的流程也可以明白为什么它被称为反向传播算法，因为我们是从最后一层的<span class="math">\(\delta^L\)</span>开始反向计算前面的<span class="math">\(\delta^l\)</span>的。因为损失函数是关于神经网络输出的函数，所以为了得到损失函数关于前面层的参数的梯度就需要不断的应用求导链式法则，一层层向前推导得到我们需要的关系的表达式。</p>
<h3 id="_7">练习</h3>
<p>问题一：</p>
<p>假设我们对神经网络中的一个神经元进行替换，使其激活函数不再是sigmoid函数，而是<span class="math">\(f(\sum_jw_jx_j + b)\)</span>, 这种情况下反向传播算法应该如何调整？</p>
<p>答案：</p>
<p>只需要修改用到激活函数的部分，首先是该神经元的输出<span class="math">\(a^l_j\)</span>用函数<span class="math">\(f\)</span>求，其次就是上面在求<span class="math">\(\sigma '(z^l)\)</span>的时候，现在改为函数<span class="math">\(f'(z^l_j)\)</span>（只影响其中一个分量，因为只替换了一个神经元）</p>
<p>问题二：</p>
<p>将神经网络中所有的sigmoid激活函数替换为线性激活函数<span class="math">\(\sigma (z) = z\)</span>，写出该情形下的反向传播算法。</p>
<p>答案：</p>
<p>使用这个激活函数的话，一个显著特征就是<span class="math">\(a=z\)</span>和<span class="math">\(\sigma '(z^L) = \vec{1}\)</span>，然后就可以去掉<span class="math">\(\odot\)</span>操作，因为右边的向量各分量都为1。其实算法没什么变化，只是这些特殊情况的激活函数会简化算法中某些式子。</p>
<p>之前已经提到过，反向传播算法是基于每一个样本计算梯度的即<span class="math">\(C = C_x\)</span>。实际中，经常会涉及到将多个梯度的情况，例如在随机梯度下降算法中使用反向传播。例如给定mini-batch大小为<span class="math">\(m\)</span>，那么算法的做法是：</p>
<ol>
<li>
<p>先针对mini-batch中每一个训练样本进行上述反向传播的计算，计算各个参数（这样就会出现m组参数）</p>
</li>
<li>
<p>在梯度下降更新参数的时候对m组梯度取平均后再应用到更新参数的公式中：</p>
</li>
</ol>
<div class="math">$$w^l \rightarrow w^l - \frac{\eta}{m}\sum_x \delta^{x, l} (a^{x, l-1})^T$$</div>
<div class="math">$$bl \rightarrow b^l - \frac{\eta}{m}\sum_x \delta^{x, l}$$</div>
<h2 id="_8">七. 反向传播算法的代码实现</h2>
<p>理解了反向传播算法后，我们再来看前一章相关代码就更容易理解了。</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">classNetwork</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> 
    <span class="n">defupdate_mini_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mini_batch</span><span class="p">,</span> <span class="n">eta</span><span class="p">):</span> 
    <span class="c1">## Update the network's weights and biases by applying </span>
    <span class="c1">## gradient descent using backpropagation to a single mini batch. </span>
    <span class="c1">## The "mini_batch" is a list of tuples "(x, y)", and "eta" </span>
    <span class="c1">## is the learning rate.</span>
    <span class="n">nabla_b</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="n">inself</span><span class="o">.</span><span class="n">biases</span><span class="p">]</span> 
    <span class="n">nabla_w</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="n">inself</span><span class="o">.</span><span class="n">weights</span><span class="p">]</span> 
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">mini_batch</span><span class="p">:</span> 
        <span class="n">delta_nabla_b</span><span class="p">,</span> <span class="n">delta_nabla_w</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">backprop</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> 
        <span class="n">nabla_b</span> <span class="o">=</span> <span class="p">[</span><span class="n">nb</span><span class="o">+</span><span class="n">dnb</span> <span class="k">for</span> <span class="n">nb</span><span class="p">,</span> <span class="n">dnb</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nabla_b</span><span class="p">,</span> <span class="n">delta_nabla_b</span><span class="p">)]</span> 
        <span class="n">nabla_w</span> <span class="o">=</span> <span class="p">[</span><span class="n">nw</span><span class="o">+</span><span class="n">dnw</span> <span class="k">for</span> <span class="n">nw</span><span class="p">,</span> <span class="n">dnw</span> <span class="n">inzip</span><span class="p">(</span><span class="n">nabla_w</span><span class="p">,</span> <span class="n">delta_nabla_w</span><span class="p">)]</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="p">(</span><span class="n">eta</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">mini_batch</span><span class="p">))</span><span class="o">*</span><span class="n">nw</span> 
        <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">nw</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="n">nabla_w</span><span class="p">)]</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">biases</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">-</span><span class="p">(</span><span class="n">eta</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">mini_batch</span><span class="p">))</span><span class="o">*</span><span class="n">nb</span> 
            <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">nb</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">biases</span><span class="p">,</span> <span class="n">nabla_b</span><span class="p">)]</span>
</pre></div>
</td></tr></table>
<p>之前已经说过，主要的计算部分在第11行的backprop函数，它返回的其实就是在当前样本下的<span class="math">\(\frac{\partial C_x}{\partial b^l_j}\)</span>和<span class="math">\(\frac{\partial C_X}{\partial w^l_{jk}}\)</span>，然后nabla_b和nabla_w是讲对应位置的结果叠加，以供在第14行和第16行更新参数时用到平均梯度时使用。下面是backprop函数的代码：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">classNetwork</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> 
    <span class="k">def</span> <span class="nf">backprop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> 
        <span class="c1">## Return a tuple "(nabla_b, nabla_w)" representing the </span>
        <span class="c1">## gradient for the cost function C_x. "nabla_b" and </span>
        <span class="c1">## "nabla_w" are layer-by-layer lists of numpy arrays, similar </span>
        <span class="c1">## to "self.biases" and "self.weights".</span>
        <span class="n">nabla_b</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">biases</span><span class="p">]</span> 
        <span class="n">nabla_w</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="n">inself</span><span class="o">.</span><span class="n">weights</span><span class="p">]</span> 
        <span class="c1">## feedforward </span>
        <span class="n">activation</span> <span class="o">=</span> <span class="n">x</span> 
        <span class="n">activations</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> 
        <span class="c1">## list to store all the activations, layer by layer </span>
        <span class="n">zs</span> <span class="o">=</span> <span class="p">[]</span> 
        <span class="c1">## list to store all the z vectors, layer by layer </span>
        <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">biases</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">):</span> 
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">activation</span><span class="p">)</span><span class="o">+</span><span class="n">b</span> <span class="mi">16</span> <span class="n">zs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> 
            <span class="n">activation</span> <span class="o">=</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> 
            <span class="n">activations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">activation</span><span class="p">)</span> 
            <span class="c1">## backward pass </span>
            <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_derivative</span><span class="p">(</span><span class="n">activations</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">)</span> 
            <span class="n">sigmoid_prime</span><span class="p">(</span><span class="n">zs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="mi">22</span> <span class="n">nabla_b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span> 
            <span class="n">nabla_w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">activations</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span> 
            <span class="c1">## Note that the variable l in the loop below is used a little </span>
            <span class="c1">## differently to the notation in Chapter 2 of the book. Here, </span>
            <span class="c1">## l = 1 means the last layer of neurons, l = 2 is the </span>
            <span class="c1">## second-last layer, and so on. It's a renumbering of the </span>
            <span class="c1">## scheme in the book, used here to take advantage of the fact </span>
            <span class="c1">## that Python can use negative indices in lists. </span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_layers</span><span class="p">):</span> 
                <span class="n">z</span> <span class="o">=</span> <span class="n">zs</span><span class="p">[</span><span class="o">-</span><span class="n">l</span><span class="p">]</span> <span class="mi">32</span> <span class="n">sp</span> <span class="o">=</span><span class="n">sigmoid_prime</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> 
                <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">delta</span><span class="p">)</span> <span class="o">*</span> <span class="n">sp</span> 
                <span class="n">nabla_b</span><span class="p">[</span><span class="o">-</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span><span class="n">delta</span> 
                <span class="n">nabla_w</span><span class="p">[</span><span class="o">-</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">activations</span><span class="p">[</span><span class="o">-</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span> 
                <span class="k">return</span><span class="p">(</span><span class="n">nabla_b</span><span class="p">,</span> <span class="n">nabla_w</span><span class="p">)</span>  
    <span class="k">def</span> <span class="nf">cost_derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_activations</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> 
        <span class="c1">## Return the vector of partial derivatives \partial C_x / \partial a for the output activations. </span>
        <span class="k">return</span> <span class="p">(</span><span class="n">output_activations</span><span class="o">-</span><span class="n">y</span><span class="p">)</span> 
    <span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">):</span> 
        <span class="c1">## The sigmoid function.</span>
        <span class="k">return</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">))</span> 
    <span class="k">def</span> <span class="nf">sigmoid_prime</span><span class="p">(</span><span class="n">z</span><span class="p">):</span> 
        <span class="c1">## Derivative of the sigmoid function.</span>
        <span class="k">return</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
</pre></div>
</td></tr></table>
<p>现在稍微解释一下这段代码：</p>
<p>8，9行是初始化一下需要计算的梯度值。</p>
<p>14-18行的for循环是计算所有的<span class="math">\(z^l_j\)</span>和<span class="math">\(a^l_j\)</span></p>
<p>20行是计算最后一层的error：<span class="math">\(\delta^L\)</span>，cost_derivate函数计算<span class="math">\(\frac{\partial C}{\partial a^L_j}\)</span>，在损失函数为二次函数的情况下为<span class="math">\(a^L_j - y_j\)</span>, sigmoid_prime函数就是计算sigmoid函数的导数。</p>
<p>22行和23行就是损失函数对输出层的参数的导数。</p>
<p>30行开始的for循环就是根据那四个方程进行反向传播的过程。</p>
<p>可见只要了解了那四个方程，反向传播算法的代码并不难理解。</p>
<p>作者最后强调他实现的代码并没有完全实现矩阵化，因为在mini-batch阶段，作者是使用for循环遍历其中的每个样本的。实际上这一步是可以依靠矩阵运算实现的，矩阵运算比遍历for循环要快。实际上，大部分的库中反向传播的实现都是依靠矩阵运算而不是循环遍历的。</p>
<h2 id="_9">八. 反向传播为什么被认为是快速的算法？</h2>
<p>我们之前提到反向传播是一种快速计算梯度的算法，那么为什么称它快速呢，这是跟什么比才说它快呢？</p>
<p>为了回答这个问题，我们先看另一种计算梯度的方法。考虑损失函数为<span class="math">\(C=C(w)\)</span>（先不考虑bias），根据导数的概念我们有：</p>
<div class="math">$$\frac{C}{w_j}\approx \frac{C(w+\epsilon e_j) - C(w)}{\epsilon} \quad (46)$$</div>
<p>其中<span class="math">\(\epsilon&gt;0\)</span>是一个很小的正数，<span class="math">\(e_j\)</span>是<span class="math">\(j\)</span>方向上的一个单位向量。这样的话通过计算分子上的损失函数C的两个值，就可以得到我们需要的梯度<span class="math">\(\frac{\partial C}{\partial w_j}\)</span>，同样的方法我们可以计算<span class="math">\(\frac{\partial C}{\partial b}\)</span>。</p>
<p>这个方法看起来很完美，而且代码实现更加容易，似乎比我们的反向传播算法更好。但是事实是，当我们尝试实现使用这种方法的时候，就会发现它的运行效率非常低下。假设我们的神经网络中有一百万个权重，那样的话为了计算梯度肯定就需要计算这一百万个<span class="math">\(C(w+\epsilon e_j)\)</span>。但是每次计算这个损失函数的值都必须从输入层开始一层层计算直到输出层（每个样本都需要经过这样的计算）。除此之外当然还需要计算一百万个<span class="math">\(C(w)\)</span>，不过这个只需要计算一次神经网络的输出即可得到。</p>
<p>反向传播算法的聪明之处在于我们只需要一次正向遍历神经网络和一次反向遍历神经网络，就可以计算出所有的<span class="math">\(\frac{\partial C}{\partial w_j}\)</span>。正向遍历计算<span class="math">\(a^l_j\)</span>和<span class="math">\(z^l_j\)</span>，反向遍历计算各个<span class="math">\(\delta ^l_j\)</span>，然后经过简单计算就得到了需要的梯度值。所以说虽然从形式上可能会觉得反向传播算法更复杂，但其实它的计算量更少，算法更高效。</p>
<p>自从反向传播算法被发现，它就解决了许多神经网络上的问题。但是反向传播算法也不是万能的，尤其是在用来训练拥有非常多隐藏层的深度神经网络的时候。我们会在本书的后面章节介绍现代计算机和一些前人聪明的想法是怎么使这样的深度神经网络的学习变得可能的。</p>
<h2 id="_10">九. 反向传播概貌</h2>
<p>到目前为止，反向传播还给我们留下了两个疑团。首先，这个算法本质上做了些什么，我们已经知道了error从输出层反向传播这个关键步骤。那我们能否了解的更深入一点，能否建立起一种直觉明白在这些矩阵向量运算背后究竟发生了什么？其次，读懂反向传播算法及其证明并不困难，但是读懂并不意味着你能凭空发现这个算法，是否存在合理的直觉或方法可以引导我们去发现这个算法呢？这一节将会围绕这两个疑团进行讨论。</p>
<p>为了让我们更直观的感受算法的行为，我们想象对神经网络的参数<span class="math">\(w^l_{jk}\)</span>进行了微调<span class="math">\(\Delta w^l_{jk}\)</span>，如下图：</p>
<p><img alt="" src="./images/sdxxsjwl27.png"/></p>
<p>当然这个变化会引起相关联的神经元的输出：</p>
<p><img alt="" src="./images/sdxxsjwl28.png"/></p>
<p>这个神经元的输出的变化又会引起和它相连接的所有的神经元的变化。就这样一层层的影响，最后就到输出层了对损失函数直接造成影响：</p>
<p><img alt="" src="./images/sdxxsjwl29.png"/></p>
<p>其中<span class="math">\(\Delta C\)</span>与权重改变的关系为：</p>
<div class="math">$$\Delta C \approx \frac{\partial C}{\partial w^l_{jk}}\Delta w^l_{jk}\quad (47)$$</div>
<p>这就给我们带来一种计算<span class="math">\(\frac{\partial C}{\partial w^l_{jk}}\)</span>的方法：通过给<span class="math">\(w^l_{jk}\)</span>引入细微的变化，然后再仔细的追踪这个变化最终对<span class="math">\(C\)</span>的影响。我们按照这种思路，从权重改变处一层层往输出层推导，最后应该就可以计算出<span class="math">\(\frac{\partial C}{\partial w^j_{jk}}\)</span>。</p>
<p>假设<span class="math">\(\Delta w^l_{jk}\)</span>会引起第<span class="math">\(l\)</span>层<span class="math">\(j\)</span>个神经元的输出改变<span class="math">\(\Delta a^l_j\)</span>：</p>
<div class="math">$$\Delta a^l_j \approx \frac{\partial a^l_j}{\partial w^l_{jk}}\Delta w^l_jk \quad (48)$$</div>
<p>这个输出的变化量<span class="math">\(\Delta a^l_j\)</span>又将会影响到下一层所有的神经元的输出。假设我们现在只关心下一层的一个神经元<span class="math">\(q\)</span>：</p>
<p><img alt="" src="./images/sdxxsjwl210.png"/></p>
<p>该神经元输出<span class="math">\(a^{l+1}_q\)</span>的改变为：</p>
<div class="math">$$\Delta a^{l+1}_q \approx \frac{\partial a^{l+1}_q}{\partial a^l_j}\Delta a^l_j \quad(49)$$</div>
<p>将其代入公式(48)得到：</p>
<div class="math">$$\Delta a^{l+1}_q \approx \frac{\partial a^{l+1}_q}{\partial a^l_j}\frac{\partial a^l_j}{\partial w^l_{jk}}\Delta w^l_{jk} \quad (50)$$</div>
<p>然后当然<span class="math">\(\Delta a^{l+1}_q\)</span>又会影响下一层的神经元的输出，这样一层层直到输出层。我们考虑其中的一条路径，假设经过的神经元输出为<span class="math">\(a^l_j, a^{l+1}_q, ..., a^{L-1}_n, a^L_m\)</span>，那么它对<span class="math">\(C\)</span>的影响为：</p>
<div class="math">$$\Delta C \approx \frac{\partial C}{\partial a^L_m}\frac{\partial a^L_m}{\partial a^{L-1}_n}\frac{\partial a^{L-1}_n}{\partial a^{L-2}_p}...\frac{\partial a^{l+1}_q}{\partial a^l_j}\frac{\partial a^l_j}{\partial w^l_{jk}}\Delta w^l_{jk}\quad (51)$$</div>
<p>当然这只是所有影响<span class="math">\(C\)</span>路径中的一条，为了计算总的变化，我们对所有可能路径的影响进行求和：</p>
<div class="math">$$\Delta C \approx \sum_{mnp...q} \frac{\partial C}{\partial a^L_m}\frac{\partial a^L_m}{\partial a^{L-1}_n}\frac{\partial a^{L-1}_n}{\partial a^{L-2}_p}...\frac{\partial a^{l+1}_q}{\partial a^l_j}\frac{\partial a^l_j}{\partial w^l_{jk}}\Delta w^l_{jk} \quad (52)$$</div>
<p>然后同公式（47）对比就能得到：</p>
<div class="math">$$\frac{\partial C}{\partial w^l_{jk}} = \sum_{mnp...q} \frac{\partial C}{\partial a^L_m}\frac{\partial a^L_m}{\partial a^{L-1}_n}\frac{\partial a^{L-1}_n}{\partial a^{L-2}_p}...\frac{\partial a^{l+1}_q}{\partial a^l_j}\frac{\partial a^l_j}{\partial w^l_{jk}} \quad (53)$$</div>
<p>方程(53)看上去挺复杂，但是它有一个非常好的直观解释。这个方程告诉我们，当我们在计算<span class="math">\(C\)</span>对于权重的变化率时，任意两个神经元之间的连接都相当于引入了一个变化率，这个变化率就是两个被连接的神经元的输出之间的导数即<span class="math">\(\frac{\partial a^{l+1}_q}{\partial a^l_j}\)</span>, 然后每一条路径带来的变化就是这些值的积，总的变化就是所有路径带来变化的和，如下图：</p>
<p><img alt="" src="./images/sdxxsjwl211.png"/></p>
<p>上面给大家提供一种思考，就是当你影响神经网络一个参数的时候，这期间会发生什么并进而影响最后的损失函数。让我们简述一下有这些知识你还可以做哪些更进一步的讨论。首先，我们可以获得方程(53)中所有单个偏导数的明确计算式，这只需要一些积分即可。然后就可以将这个求和的运算改成矩阵相乘的形式。你就会渐渐发现我们现在做的就是反向传播所做的事情，所以说反向传播算法可以被认为是计算所有路径上偏导数积的和的一种方法。或者说，反向传播提供了一种追踪权重变化对神经网络输出影响的途径。</p>
<p>反向传播算法的介绍就到这里了，之前还看到过<a href="http://colah.github.io/posts/2015-08-Backprop/#fnref1">一篇脱离神经网络单独介绍反向传播的好的博文</a>，以后再抽时间介绍。</p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
            
            
            <hr/>
            <aside>
            <nav>
            <ul class="articles-timeline">
                <li class="previous-article">« <a href="/shen-du-xue-xi-yu-shen-jing-wang-luo-bi-ji-1.html" title="Previous: 《深度学习与神经网络》笔记1 - 使用神经网络识别手写数字">《深度学习与神经网络》笔记1 <small>使用神经网络识别手写数字</small></a></li>
                <li class="next-article"><a href="/shen-du-xue-xi-yu-shen-jing-wang-luo-bi-ji-3.html" title="Next: 《深度学习与神经网络》笔记3 - 如何提高神经网络学习算法的效果">《深度学习与神经网络》笔记3 <small>如何提高神经网络学习算法的效果</small></a> »</li>
            </ul>
            </nav>
            </aside>
        </div>
        <section>
        <div class="span2" style="float:right;font-size:0.9em;">
            <h4>Published</h4>
            <time pubdate="pubdate" datetime="2017-09-01T20:00:00+08:00">2017  - 09  - 01</time>
            <h4>Category</h4>
            <a class="category-link" href="/categories.html#shen-du-xue-xi-ref">深度学习
                <span>(10)</span>
</a>
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="/tags.html#shen-du-xue-xi-ref">深度学习
                    <span>10</span>
</a></li>
                <li><a href="/tags.html#shen-du-xue-xi-yu-shen-jing-wang-luo-bi-ji-ref">《深度学习与神经网络》笔记
                    <span>6</span>
</a></li>
                <li><a href="/tags.html#suan-fa-ref">算法
                    <span>13</span>
</a></li>
            </ul>
                <div class="widget blogroll">
                        <h4>Blogroll</h4>
                        <ul>
                            <li><a href="http://blogwall.us/">Blogwall</a></li>
                            <li><a href="http://www.matrix67.com/">Matrix67</a></li>
                            <li><a href="http://blog.echen.me/">EdwinChen</a></li>
                        </ul>
                </div><!-- /.blogroll -->
<h4>Contact</h4>
    <a href="mailto:shangzhi.huang@gmail.com" title="My email Address" class="sidebar-social-links" target="_blank">
    <i class="fa fa-envelope sidebar-social-links"></i></a>
    <a href="https://github.com/ShangzhiH" title="My github Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-github sidebar-social-links"></i></a>
    <a href="feeds/all.rss.xml" title="Subscribe in a reader" class="sidebar-social-links" target="_blank">
    <i class="fa fa-rss sidebar-social-links"></i></a>
        </div>
        </section>
</div>
</article>
                </div>
                <div class="span1"></div>
            </div>
        </div>
        <div id="push"></div>
    </div>
<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a></li>
    </ul>
</div>
</footer>            <script src="http://code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

    
    </body>
    <!-- Theme: Elegant built for Pelican
    License : http://oncrashreboot.com/pelican-elegant -->
</html>